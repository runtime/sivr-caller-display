{"ast":null,"code":"var path = require('path'); // path.isAbsolute shim for Node.js 0.10 support\n\n\npath.isAbsolute = path.isAbsolute ? path.isAbsolute : require('path-is-absolute');\n\nvar fs = require('graceful-fs');\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\n\nfunction symlinkPaths(srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, function (err, stat) {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink');\n        return callback(err);\n      }\n\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      });\n    });\n  } else {\n    var dstdir = path.dirname(dstpath);\n    var relativeToDst = path.join(dstdir, srcpath);\n    return fs.exists(relativeToDst, function (exists) {\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        });\n      } else {\n        return fs.lstat(srcpath, function (err, stat) {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink');\n            return callback(err);\n          }\n\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          });\n        });\n      }\n    });\n  }\n}\n\nfunction symlinkPathsSync(srcpath, dstpath) {\n  var exists;\n\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath);\n    if (!exists) throw new Error('absolute srcpath does not exist');\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    };\n  } else {\n    var dstdir = path.dirname(dstpath);\n    var relativeToDst = path.join(dstdir, srcpath);\n    exists = fs.existsSync(relativeToDst);\n\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      };\n    } else {\n      exists = fs.existsSync(srcpath);\n      if (!exists) throw new Error('relative srcpath does not exist');\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      };\n    }\n  }\n}\n\nmodule.exports = {\n  'symlinkPaths': symlinkPaths,\n  'symlinkPathsSync': symlinkPathsSync\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/node_modules/fs-extra/lib/ensure/symlink-paths.js"],"names":["path","require","isAbsolute","fs","symlinkPaths","srcpath","dstpath","callback","lstat","err","stat","message","replace","dstdir","dirname","relativeToDst","join","exists","relative","symlinkPathsSync","existsSync","Error","module","exports"],"mappings":"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","sourcesContent":["var path = require('path')\n// path.isAbsolute shim for Node.js 0.10 support\npath.isAbsolute = (path.isAbsolute) ? path.isAbsolute : require('path-is-absolute')\nvar fs = require('graceful-fs')\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, function (err, stat) {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    var dstdir = path.dirname(dstpath)\n    var relativeToDst = path.join(dstdir, srcpath)\n    return fs.exists(relativeToDst, function (exists) {\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, function (err, stat) {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  var exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    var dstdir = path.dirname(dstpath)\n    var relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  'symlinkPaths': symlinkPaths,\n  'symlinkPathsSync': symlinkPathsSync\n}\n"]},"metadata":{},"sourceType":"script"}