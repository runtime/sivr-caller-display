{"ast":null,"code":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar jws = require('jws');\n\nvar noop = require('lodash.noop');\n/**\n * JWTAccess service account credentials.\n *\n * Create a new access token by using the credential to create a new JWT token\n * that's recognized as the access token.\n *\n * @param {string=} email the service account email address.\n * @param {string=} key the private key that will be used to sign the token.\n * @constructor\n */\n\n\nfunction JWTAccess(email, key) {\n  this.email = email;\n  this.key = key;\n}\n/**\n * Indicates whether the credential requires scopes to be created by calling\n * createdScoped before use.\n *\n * @return {boolean} always false\n */\n\n\nJWTAccess.prototype.createScopedRequired = function () {\n  // JWT Header authentication does not use scopes.\n  return false;\n};\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {string} authURI the URI being authorized\n * @param {function} metadataCb a callback invoked with the jwt\n *                   request metadata.\n */\n\n\nJWTAccess.prototype.getRequestMetadata = function (authURI, metadataCb) {\n  var iat = Math.floor(new Date().getTime() / 1000);\n  var exp = iat + 3600; // 3600 seconds = 1 hour\n  // The payload used for signed JWT headers has:\n  // iss == sub == <client email>\n  // aud == <the authorization uri>\n\n  var payload = {\n    iss: this.email,\n    sub: this.email,\n    aud: authURI,\n    exp: exp,\n    iat: iat\n  };\n  var assertion = {\n    header: {\n      alg: 'RS256',\n      typ: 'JWT'\n    },\n    payload: payload,\n    secret: this.key\n  }; // Sign the jwt and invoke metadataCb with it.\n\n  return this._signJWT(assertion, function (err, signedJWT) {\n    if (!err) {\n      return metadataCb(null, {\n        'Authorization': 'Bearer ' + signedJWT\n      });\n    } else {\n      return metadataCb(err, null);\n    }\n  });\n};\n/**\n * Create a JWTAccess credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWTAccess.prototype.fromJSON = function (json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!json) {\n    done(new Error('Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n\n  if (!json.client_email) {\n    done(new Error('The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n\n  if (!json.private_key) {\n    done(new Error('The incoming JSON object does not contain a private_key field'));\n    return;\n  } // Extract the relevant information from the json key file.\n\n\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n/**\n * Create a JWTAccess credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWTAccess.prototype.fromStream = function (stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!stream) {\n    process.nextTick(function () {\n      done(new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n/**\n * Sign the JWT object, returning any errors in the callback.\n *\n * signedJwtFn is a callback function(err, signedJWT); it is called with an\n * error if there is an exception during signing.\n *\n * @param  {object}   assertion   The assertion to sign\n * @param  {Function} signedJwtFn  fn(err, signedJWT)\n */\n\n\nJWTAccess.prototype._signJWT = function (assertion, signedJwtFn) {\n  try {\n    return signedJwtFn(null, jws.sign(assertion));\n  } catch (err) {\n    return signedJwtFn(err);\n  }\n};\n/**\n * Export JWTAccess.\n */\n\n\nmodule.exports = JWTAccess;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/google-auto-auth/node_modules/google-auth-library/lib/auth/jwtaccess.js"],"names":["jws","require","noop","JWTAccess","email","key","prototype","createScopedRequired","getRequestMetadata","authURI","metadataCb","iat","Math","floor","Date","getTime","exp","payload","iss","sub","aud","assertion","header","alg","typ","secret","_signJWT","err","signedJWT","fromJSON","json","opt_callback","that","done","Error","client_email","private_key","projectId","project_id","fromStream","stream","process","nextTick","s","setEncoding","on","chunk","data","JSON","parse","signedJwtFn","sign","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar jws = require('jws');\nvar noop = require('lodash.noop');\n\n/**\n * JWTAccess service account credentials.\n *\n * Create a new access token by using the credential to create a new JWT token\n * that's recognized as the access token.\n *\n * @param {string=} email the service account email address.\n * @param {string=} key the private key that will be used to sign the token.\n * @constructor\n */\nfunction JWTAccess(email, key) {\n  this.email = email;\n  this.key = key;\n}\n\n/**\n * Indicates whether the credential requires scopes to be created by calling\n * createdScoped before use.\n *\n * @return {boolean} always false\n */\nJWTAccess.prototype.createScopedRequired = function() {\n  // JWT Header authentication does not use scopes.\n  return false;\n};\n\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {string} authURI the URI being authorized\n * @param {function} metadataCb a callback invoked with the jwt\n *                   request metadata.\n */\nJWTAccess.prototype.getRequestMetadata = function(authURI, metadataCb) {\n  var iat = Math.floor(new Date().getTime() / 1000);\n  var exp = iat + 3600; // 3600 seconds = 1 hour\n\n  // The payload used for signed JWT headers has:\n  // iss == sub == <client email>\n  // aud == <the authorization uri>\n  var payload = {\n    iss: this.email,\n    sub: this.email,\n    aud: authURI,\n    exp: exp,\n    iat: iat\n  };\n  var assertion = {\n    header: {\n      alg: 'RS256',\n      typ: 'JWT'\n    },\n    payload: payload,\n    secret: this.key\n  };\n\n  // Sign the jwt and invoke metadataCb with it.\n  return this._signJWT(assertion, function(err, signedJWT) {\n    if (!err) {\n      return metadataCb(null, {'Authorization': 'Bearer ' + signedJWT});\n    } else {\n      return metadataCb(err, null);\n    }\n  });\n};\n\n/**\n * Create a JWTAccess credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nJWTAccess.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!json) {\n    done(new Error(\n      'Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n  if (!json.client_email) {\n    done(new Error(\n      'The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n  if (!json.private_key) {\n    done(new Error(\n      'The incoming JSON object does not contain a private_key field'));\n    return;\n  }\n  // Extract the relevant information from the json key file.\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n\n/**\n * Create a JWTAccess credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nJWTAccess.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!stream) {\n    process.nextTick(function() {\n        done(\n            new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n\n/**\n * Sign the JWT object, returning any errors in the callback.\n *\n * signedJwtFn is a callback function(err, signedJWT); it is called with an\n * error if there is an exception during signing.\n *\n * @param  {object}   assertion   The assertion to sign\n * @param  {Function} signedJwtFn  fn(err, signedJWT)\n */\nJWTAccess.prototype._signJWT = function(assertion, signedJwtFn) {\n  try {\n    return signedJwtFn(null, jws.sign(assertion));\n  } catch (err) {\n    return signedJwtFn(err);\n  }\n};\n\n/**\n * Export JWTAccess.\n */\nmodule.exports = JWTAccess;\n"]},"metadata":{},"sourceType":"script"}