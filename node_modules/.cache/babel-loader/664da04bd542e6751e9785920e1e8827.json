{"ast":null,"code":"/*\n * file.js: Transport for outputting to a local log file\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\nvar events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    async = require('async'),\n    zlib = require('zlib'),\n    common = require('../common'),\n    Transport = require('./transport').Transport,\n    isWritable = require('isstream').isWritable,\n    Stream = require('stream').Stream,\n    os = require('os'); //\n// ### function File (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the File transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\n\n\nvar File = exports.File = function (options) {\n  var self = this;\n  Transport.call(this, options); //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n\n  function throwIf(target\n  /*, illegal... */\n  ) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename ? path.basename(options.filename) : 'winston.log';\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || {\n      flags: 'a'\n    }; //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  } else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    this._isStreams2 = isWritable(this._stream);\n\n    this._stream.on('error', function (error) {\n      self.emit('error', error);\n    }); //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n\n\n    this._stream.setMaxListeners(Infinity);\n  } else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json = options.json !== false;\n  this.logstash = options.logstash || false;\n  this.colorize = options.colorize || false;\n  this.maxsize = options.maxsize || null;\n  this.rotationFormat = options.rotationFormat || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxFiles = options.maxFiles || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.label = options.label || null;\n  this.timestamp = options.timestamp != null ? options.timestamp : true;\n  this.eol = options.eol || os.EOL;\n  this.tailable = options.tailable || false;\n  this.depth = options.depth || null;\n  this.showLevel = options.showLevel === undefined ? true : options.showLevel;\n  this.maxRetries = options.maxRetries || 2;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  } //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n\n\n  this._size = 0;\n  this._created = 0;\n  this._buffer = [];\n  this._draining = false;\n  this._opening = false;\n  this._failures = 0;\n  this._archive = null;\n}; //\n// Inherit from `winston.Transport`.\n//\n\n\nutil.inherits(File, Transport); //\n// Expose the name of this Transport on the prototype\n//\n\nFile.prototype.name = 'file'; //\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\n\nFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  } //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n\n\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  if (typeof msg !== 'string') {\n    msg = '' + msg;\n  }\n\n  var output = common.log({\n    level: level,\n    message: msg,\n    meta: meta,\n    json: this.json,\n    logstash: this.logstash,\n    colorize: this.colorize,\n    prettyPrint: this.prettyPrint,\n    timestamp: this.timestamp,\n    showLevel: this.showLevel,\n    stringify: this.stringify,\n    label: this.label,\n    depth: this.depth,\n    formatter: this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  }) + this.eol;\n\n  if (!this.filename) {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n\n    this._size += output.length;\n\n    this._lazyDrain();\n  } else {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n\n      self._size += output.length;\n\n      self._lazyDrain();\n    });\n  }\n}; //\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\n\n\nFile.prototype._write = function (data, callback) {\n  if (this._isStreams2) {\n    this._stream.write(data);\n\n    return callback && process.nextTick(function () {\n      callback(null, true);\n    });\n  } // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n\n\n  var ret = this._stream.write(data);\n\n  if (!callback) return;\n\n  if (ret === false) {\n    return this._stream.once('drain', function () {\n      callback(null, true);\n    });\n  }\n\n  process.nextTick(function () {\n    callback(null, true);\n  });\n}; //\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\n\n\nFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var file = path.join(this.dirname, this.filename),\n      options = this.normalizeQuery(options),\n      buff = '',\n      results = [],\n      row = 0;\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n\n    if (!callback) return;\n    return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n  });\n  stream.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n\n      row++;\n    }\n\n    buff = data[l];\n  });\n  stream.on('close', function () {\n    if (buff) add(buff, true);\n\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n\n    if (callback) callback(null, results);\n  });\n\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) push(log);\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n\n  function push(log) {\n    if (options.rows && results.length >= options.rows) {\n      if (stream.readable) {\n        stream.destroy();\n      }\n\n      return;\n    }\n\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n\n    results.push(log);\n  }\n\n  function check(log) {\n    if (!log) return;\n    if (typeof log !== 'object') return;\n    var time = new Date(log.timestamp);\n\n    if (options.from && time < options.from || options.until && time > options.until) {\n      return;\n    }\n\n    return true;\n  }\n}; //\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\n\n\nFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this.filename),\n      options = options || {},\n      stream = new Stream();\n  var tail = {\n    file: file,\n    start: options.start\n  };\n  stream.destroy = common.tailFile(tail, function (err, line) {\n    if (err) {\n      return stream.emit('error', err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n  return stream;\n}; //\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\n\n\nFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  } else if (!this._stream || this.maxsize && this._size >= this.maxsize) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  this._archive = this.zippedArchive ? this._stream.path : null; //\n  // Otherwise we have a valid (and ready) stream.\n  //\n\n  callback();\n}; //\n// ### function close ()\n// Closes the stream associated with this instance.\n//\n\n\nFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n\n    this._stream.destroySoon();\n\n    this._stream.once('finish', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n}; //\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\n\n\nFile.prototype.flush = function () {\n  var self = this; // If nothing to flush, there will be no \"flush\" event from native stream\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\n  // That means, self.opening will never set to false and no logs will be written to disk\n\n  if (!this._buffer.length) {\n    return self.emit('flush');\n  } //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n\n\n  this._buffer.forEach(function (item) {\n    var str = item[0],\n        callback = item[1];\n    process.nextTick(function () {\n      self._write(str, callback);\n\n      self._size += str.length;\n    });\n  }); //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n\n\n  self._buffer.length = 0; //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n}; //\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\n\n\nFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile(target) {\n    var fullname = path.join(self.dirname, target); //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n\n    function createAndFlush(size) {\n      if (self._stream) {\n        self._stream.end();\n\n        self._stream.destroySoon();\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._isStreams2 = isWritable(self._stream);\n\n      self._stream.on('error', function (error) {\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n\n          self._failures++;\n        } else {\n          self.emit('error', error);\n        }\n      }); //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n\n\n      self._stream.setMaxListeners(Infinity); //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n\n\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n        self.opening = false;\n        self.emit('open', fullname);\n      }); //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      if (self._archive) {\n        var gzip = zlib.createGzip();\n        var inp = fs.createReadStream(String(self._archive));\n        var out = fs.createWriteStream(self._archive + '.gz');\n        inp.pipe(gzip).pipe(out);\n        fs.unlink(String(self._archive));\n        self._archive = '';\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n\n        return createAndFlush(0);\n      }\n\n      if (!stats || self.maxsize && stats.size >= self.maxsize) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return self._incFile(function () {\n          checkFile(self._getFile());\n        });\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\nFile.prototype._incFile = function (callback) {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext),\n      oldest,\n      target;\n\n  if (!this.tailable) {\n    this._created += 1;\n\n    this._checkMaxFilesIncrementing(ext, basename, callback);\n  } else {\n    this._checkMaxFilesTailable(ext, basename, callback);\n  }\n}; //\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\n\n\nFile.prototype._getFile = function () {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext); //\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\n  // when combined with max files because the set of files to unlink\n  // is never stored.\n  //\n\n  return !this.tailable && this._created ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext : basename + ext;\n}; //\n// ### @private function _checkMaxFilesIncrementing ()\n// Increment the number of files created or\n// checked by this instance.\n//\n\n\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\n  var oldest,\n      target,\n      self = this;\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + (self._created === 1 ? '' : self._created - 1) + ext);\n  } // Check for maxFiles option and delete file\n\n\n  if (!self.maxFiles || self._created < self.maxFiles) {\n    return callback();\n  }\n\n  oldest = self._created - self.maxFiles;\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext + (self.zippedArchive ? '.gz' : ''));\n  fs.unlink(target, callback);\n}; //\n// ### @private function _checkMaxFilesTailable ()\n//\n// Roll files forward based on integer, up to maxFiles.\n// e.g. if base if file.log and it becomes oversized, roll\n//    to file1.log, and allow file.log to be re-used. If\n//    file is oversized again, roll file1.log to file2.log,\n//    roll file.log to file1.log, and so on.\n\n\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\n  var tasks = [],\n      self = this;\n  if (!this.maxFiles) return;\n\n  for (var x = this.maxFiles - 1; x > 0; x--) {\n    tasks.push(function (i) {\n      return function (cb) {\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext + (self.zippedArchive ? '.gz' : ''));\n        fs.exists(tmppath, function (exists) {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext + (self.zippedArchive ? '.gz' : '')), cb);\n        });\n      };\n    }(x));\n  }\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + 1 + ext);\n  }\n\n  async.series(tasks, function (err) {\n    fs.rename(path.join(self.dirname, basename + ext), path.join(self.dirname, basename + 1 + ext), callback);\n  });\n}; //\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\n\n\nFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/winston/lib/winston/transports/file.js"],"names":["events","require","fs","path","util","async","zlib","common","Transport","isWritable","Stream","os","File","exports","options","self","call","throwIf","target","Array","prototype","slice","arguments","forEach","name","Error","filename","dirname","_basename","basename","flags","highWaterMark","stream","_stream","_isStreams2","on","error","emit","setMaxListeners","Infinity","json","logstash","colorize","maxsize","rotationFormat","zippedArchive","maxFiles","prettyPrint","label","timestamp","eol","EOL","tailable","depth","showLevel","undefined","maxRetries","stringify","_size","_created","_buffer","_draining","_opening","_failures","_archive","inherits","log","level","msg","meta","callback","silent","output","message","formatter","humanReadableUnhandledException","_write","length","_lazyDrain","open","err","push","data","write","process","nextTick","ret","once","query","file","join","normalizeQuery","buff","results","row","createReadStream","encoding","readable","destroy","code","split","l","i","start","add","order","reverse","attempt","JSON","parse","check","e","rows","fields","obj","key","time","Date","from","until","tail","tailFile","line","opening","_createStream","close","end","destroySoon","flush","item","str","checkFile","fullname","createAndFlush","size","createWriteStream","compressFile","gzip","createGzip","inp","String","out","pipe","unlink","stat","stats","_incFile","_getFile","ext","extname","oldest","_checkMaxFilesIncrementing","_checkMaxFilesTailable","tasks","x","cb","tmppath","exists","rename","series"],"mappings":"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","sourcesContent":["/*\n * file.js: Transport for outputting to a local log file\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    async = require('async'),\n    zlib = require('zlib'),\n    common = require('../common'),\n    Transport = require('./transport').Transport,\n    isWritable = require('isstream').isWritable,\n    Stream = require('stream').Stream,\n    os = require('os');\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the File transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar File = exports.File = function (options) {\n  var self = this;\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf (target /*, illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename\n      ? path.basename(options.filename)\n      : 'winston.log';\n\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || { flags: 'a' };\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  }\n  else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    this._isStreams2 = isWritable(this._stream);\n    this._stream.on('error', function(error){\n      self.emit('error', error);\n    });\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  }\n  else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json        = options.json !== false;\n  this.logstash    = options.logstash    || false;\n  this.colorize    = options.colorize    || false;\n  this.maxsize     = options.maxsize     || null;\n  this.rotationFormat = options.rotationFormat || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxFiles    = options.maxFiles    || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.label       = options.label       || null;\n  this.timestamp   = options.timestamp != null ? options.timestamp : true;\n  this.eol         = options.eol || os.EOL;\n  this.tailable    = options.tailable    || false;\n  this.depth       = options.depth       || null;\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\n  this.maxRetries  = options.maxRetries || 2;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size     = 0;\n  this._created  = 0;\n  this._buffer   = [];\n  this._draining = false;\n  this._opening  = false;\n  this._failures = 0;\n  this._archive = null;\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(File, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nFile.prototype.name = 'file';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  if (typeof msg !== 'string') {\n    msg = '' + msg;\n  }\n\n  var output = common.log({\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    json:        this.json,\n    logstash:    this.logstash,\n    colorize:    this.colorize,\n    prettyPrint: this.prettyPrint,\n    timestamp:   this.timestamp,\n    showLevel:   this.showLevel,\n    stringify:   this.stringify,\n    label:       this.label,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  }) + this.eol;\n\n\n  if (!this.filename) {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._size += output.length;\n    this._lazyDrain();\n  }\n  else {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n      self._size += output.length;\n      self._lazyDrain();\n    });\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nFile.prototype._write = function(data, callback) {\n  if (this._isStreams2) {\n    this._stream.write(data);\n    return callback && process.nextTick(function () {\n      callback(null, true);\n    });\n  }\n\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) return;\n  if (ret === false) {\n    return this._stream.once('drain', function() {\n      callback(null, true);\n    });\n  }\n  process.nextTick(function () {\n    callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var file = path.join(this.dirname, this.filename),\n      options = this.normalizeQuery(options),\n      buff = '',\n      results = [],\n      row = 0;\n\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n    if (!callback) return;\n    return err.code !== 'ENOENT'\n      ? callback(err)\n      : callback(null, results);\n  });\n\n  stream.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n      row++;\n    }\n\n    buff = data[l];\n  });\n\n  stream.on('close', function () {\n    if (buff) add(buff, true);\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n    if (callback) callback(null, results);\n  });\n\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) push(log);\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n\n  function push(log) {\n    if (options.rows && results.length >= options.rows) {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      return;\n    }\n\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n\n    results.push(log);\n  }\n\n  function check(log) {\n    if (!log) return;\n\n    if (typeof log !== 'object') return;\n\n    var time = new Date(log.timestamp);\n    if ((options.from && time < options.from)\n        || (options.until && time > options.until)) {\n      return;\n    }\n\n    return true;\n  }\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this.filename),\n      options = options || {},\n      stream = new Stream;\n\n  var tail = {\n    file: file,\n    start: options.start\n  };\n\n  stream.destroy = common.tailFile(tail, function (err, line) {\n\n    if(err){\n      return stream.emit('error',err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  }\n  else if (!this._stream || (this.maxsize && this._size >= this.maxsize)) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  this._archive = this.zippedArchive ? this._stream.path : null;\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n\n    this._stream.once('finish', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nFile.prototype.flush = function () {\n  var self = this;\n\n  // If nothing to flush, there will be no \"flush\" event from native stream\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\n  // That means, self.opening will never set to false and no logs will be written to disk\n  if (!this._buffer.length) {\n    return self.emit('flush');\n  }\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0],\n        callback = item[1];\n\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile (target) {\n    var fullname = path.join(self.dirname, target);\n\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush (size) {\n      if (self._stream) {\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._isStreams2 = isWritable(self._stream);\n      self._stream.on('error', function(error){\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        }\n        else {\n          self.emit('error', error);\n        }\n      });\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      if (self._archive) {\n        var gzip = zlib.createGzip();\n\n        var inp = fs.createReadStream(String(self._archive));\n        var out = fs.createWriteStream(self._archive + '.gz');\n\n        inp.pipe(gzip).pipe(out);\n\n        fs.unlink(String(self._archive));\n        self._archive = '';\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n        return createAndFlush(0);\n      }\n\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return self._incFile(function() {\n          checkFile(self._getFile());\n        });\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\n\nFile.prototype._incFile = function (callback) {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext),\n      oldest,\n      target;\n\n  if (!this.tailable) {\n    this._created += 1;\n    this._checkMaxFilesIncrementing(ext, basename, callback);\n  }\n  else {\n    this._checkMaxFilesTailable(ext, basename, callback);\n  }\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nFile.prototype._getFile = function () {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext);\n\n  //\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\n  // when combined with max files because the set of files to unlink\n  // is never stored.\n  //\n  return !this.tailable && this._created\n    ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext\n    : basename + ext;\n};\n\n//\n// ### @private function _checkMaxFilesIncrementing ()\n// Increment the number of files created or\n// checked by this instance.\n//\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\n  var oldest, target,\n    self = this;\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename +\n        ((self._created === 1) ? '' : self._created-1) +\n        ext);\n  }\n\n\n  // Check for maxFiles option and delete file\n  if (!self.maxFiles || self._created < self.maxFiles) {\n    return callback();\n  }\n\n  oldest = self._created - self.maxFiles;\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext +\n    (self.zippedArchive ? '.gz' : ''));\n  fs.unlink(target, callback);\n};\n\n//\n// ### @private function _checkMaxFilesTailable ()\n//\n// Roll files forward based on integer, up to maxFiles.\n// e.g. if base if file.log and it becomes oversized, roll\n//    to file1.log, and allow file.log to be re-used. If\n//    file is oversized again, roll file1.log to file2.log,\n//    roll file.log to file1.log, and so on.\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\n  var tasks = [],\n      self = this;\n\n  if (!this.maxFiles)\n    return;\n\n  for (var x = this.maxFiles - 1; x > 0; x--) {\n    tasks.push(function (i) {\n      return function (cb) {\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext +\n          (self.zippedArchive ? '.gz' : ''));\n        fs.exists(tmppath, function (exists) {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext +\n            (self.zippedArchive ? '.gz' : '')), cb);\n        });\n      };\n    }(x));\n  }\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + 1 + ext);\n  }\n  async.series(tasks, function (err) {\n    fs.rename(\n      path.join(self.dirname, basename + ext),\n      path.join(self.dirname, basename + 1 + ext),\n      callback\n    );\n  });\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}