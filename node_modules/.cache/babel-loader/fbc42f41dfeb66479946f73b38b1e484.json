{"ast":null,"code":"/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\nvar cycle = exports;\n\ncycle.decycle = function decycle(object) {\n  'use strict'; // Make a deep copy of an object or array, assuring that there is at most\n  // one instance of each object or array in the resulting structure. The\n  // duplicate references (which might be forming cycles) are replaced with\n  // an object of the form\n  //      {$ref: PATH}\n  // where the PATH is a JSONPath string that locates the first occurance.\n  // So,\n  //      var a = [];\n  //      a[0] = a;\n  //      return JSON.stringify(JSON.decycle(a));\n  // produces the string '[{\"$ref\":\"$\"}]'.\n  // JSONPath is used to locate the unique object. $ indicates the top level of\n  // the object or array. [NUMBER] or [STRING] indicates a child member or\n  // property.\n\n  var objects = [],\n      // Keep a reference to each unique object or array\n  paths = []; // Keep the path to each unique object or array\n\n  return function derez(value, path) {\n    // The derez recurses through the object, producing the deep copy.\n    var i, // The loop counter\n    name, // Property name\n    nu; // The new object or array\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === value) {\n          return {\n            $ref: paths[i]\n          };\n        }\n      } // Otherwise, accumulate the unique value and its path.\n\n\n      objects.push(value);\n      paths.push(path); // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        nu = [];\n\n        for (i = 0; i < value.length; i += 1) {\n          nu[i] = derez(value[i], path + '[' + i + ']');\n        }\n      } else {\n        // If it is an object, replicate the object.\n        nu = {};\n\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n          }\n        }\n      }\n\n      return nu;\n    }\n\n    return value;\n  }(object, '$');\n};\n\ncycle.retrocycle = function retrocycle($) {\n  'use strict'; // Restore an object that was reduced by decycle. Members whose values are\n  // objects of the form\n  //      {$ref: PATH}\n  // are replaced with references to the value found by the PATH. This will\n  // restore cycles. The object will be mutated.\n  // The eval function is used to locate the values described by a PATH. The\n  // root object is kept in a $ variable. A regular expression is used to\n  // assure that the PATH is extremely well formed. The regexp contains nested\n  // * quantifiers. That has been known to have extremely bad performance\n  // problems on some browsers for very long strings. A PATH is expected to be\n  // reasonably short. A PATH is allowed to belong to a very restricted subset of\n  // Goessner's JSONPath.\n  // So,\n  //      var s = '[{\"$ref\":\"$\"}]';\n  //      return JSON.retrocycle(JSON.parse(s));\n  // produces an array containing a single element which is the array itself.\n\n  var px = /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n\n  (function rez(value) {\n    // The rez function walks recursively through the object looking for $ref\n    // properties. When it finds one that has a value that is a path, then it\n    // replaces the $ref object with a reference to the value that is found by\n    // the path.\n    var i, item, name, path;\n\n    if (value && typeof value === 'object') {\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        for (i = 0; i < value.length; i += 1) {\n          item = value[i];\n\n          if (item && typeof item === 'object') {\n            path = item.$ref;\n\n            if (typeof path === 'string' && px.test(path)) {\n              value[i] = eval(path);\n            } else {\n              rez(item);\n            }\n          }\n        }\n      } else {\n        for (name in value) {\n          if (typeof value[name] === 'object') {\n            item = value[name];\n\n            if (item) {\n              path = item.$ref;\n\n              if (typeof path === 'string' && px.test(path)) {\n                value[name] = eval(path);\n              } else {\n                rez(item);\n              }\n            }\n          }\n        }\n      }\n    }\n  })($);\n\n  return $;\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/cycle/cycle.js"],"names":["cycle","exports","decycle","object","objects","paths","derez","value","path","i","name","nu","Boolean","Date","Number","RegExp","String","length","$ref","push","Object","prototype","toString","apply","hasOwnProperty","call","JSON","stringify","retrocycle","$","px","rez","item","test","eval"],"mappings":"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","sourcesContent":["/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\n\nvar cycle = exports;\n\ncycle.decycle = function decycle(object) {\n    'use strict';\n\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n\n\ncycle.retrocycle = function retrocycle($) {\n    'use strict';\n\n// Restore an object that was reduced by decycle. Members whose values are\n// objects of the form\n//      {$ref: PATH}\n// are replaced with references to the value found by the PATH. This will\n// restore cycles. The object will be mutated.\n\n// The eval function is used to locate the values described by a PATH. The\n// root object is kept in a $ variable. A regular expression is used to\n// assure that the PATH is extremely well formed. The regexp contains nested\n// * quantifiers. That has been known to have extremely bad performance\n// problems on some browsers for very long strings. A PATH is expected to be\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\n// Goessner's JSONPath.\n\n// So,\n//      var s = '[{\"$ref\":\"$\"}]';\n//      return JSON.retrocycle(JSON.parse(s));\n// produces an array containing a single element which is the array itself.\n\n    var px =\n        /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n\n    (function rez(value) {\n\n// The rez function walks recursively through the object looking for $ref\n// properties. When it finds one that has a value that is a path, then it\n// replaces the $ref object with a reference to the value that is found by\n// the path.\n\n        var i, item, name, path;\n\n        if (value && typeof value === 'object') {\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                for (i = 0; i < value.length; i += 1) {\n                    item = value[i];\n                    if (item && typeof item === 'object') {\n                        path = item.$ref;\n                        if (typeof path === 'string' && px.test(path)) {\n                            value[i] = eval(path);\n                        } else {\n                            rez(item);\n                        }\n                    }\n                }\n            } else {\n                for (name in value) {\n                    if (typeof value[name] === 'object') {\n                        item = value[name];\n                        if (item) {\n                            path = item.$ref;\n                            if (typeof path === 'string' && px.test(path)) {\n                                value[name] = eval(path);\n                            } else {\n                                rez(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }($));\n    return $;\n};\n"]},"metadata":{},"sourceType":"script"}