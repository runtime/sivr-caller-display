{"ast":null,"code":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar AuthClient = require('./authclient.js');\n\nvar LoginTicket = require('./loginticket.js');\n\nvar noop = require('lodash.noop');\n\nvar PemVerifier = require('./../pemverifier.js');\n\nvar querystring = require('querystring');\n\nvar util = require('util');\n\nvar certificateCache = null;\nvar certificateExpiry = null;\n/**\n * Handles OAuth2 flow for Google APIs.\n *\n * @param {string} clientId The authentication client ID.\n * @param {string} clientSecret The authentication client secret.\n * @param {string} redirectUri The URI to redirect to after completing the auth request.\n * @param {Object} opt_opts optional options for overriding the given parameters.\n * @constructor\n */\n\nfunction OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) {\n  OAuth2Client.super_.call(this);\n  this.clientId_ = clientId;\n  this.clientSecret_ = clientSecret;\n  this.redirectUri_ = redirectUri;\n  this.opts = opt_opts || {};\n  this.credentials = {};\n}\n/**\n * Inherit from AuthClient.\n */\n\n\nutil.inherits(OAuth2Client, AuthClient);\n/**\n * The base URL for auth endpoints.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/auth';\n/**\n * The base endpoint for token retrieval.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://accounts.google.com/o/oauth2/token';\n/**\n * The base endpoint to revoke tokens.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://accounts.google.com/o/oauth2/revoke';\n/**\n * Google Sign on certificates.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Clock skew - five minutes in seconds\n * @const\n * @private\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n * @const\n * @private\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n * @const\n * @private\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n/**\n * Generates URL for consent page landing.\n * @param {object=} opt_opts Options.\n * @return {string} URL to consent page.\n */\n\nOAuth2Client.prototype.generateAuthUrl = function (opt_opts) {\n  var opts = opt_opts || {};\n  opts.response_type = opts.response_type || 'code';\n  opts.client_id = opts.client_id || this.clientId_;\n  opts.redirect_uri = opts.redirect_uri || this.redirectUri_; // Allow scopes to be passed either as array or a string\n\n  if (opts.scope instanceof Array) {\n    opts.scope = opts.scope.join(' ');\n  }\n\n  var rootUrl = this.opts.authBaseUrl || OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n  return rootUrl + '?' + querystring.stringify(opts);\n};\n/**\n * Gets the access token for the given code.\n * @param {string} code The authorization code.\n * @param {function=} opt_callback Optional callback fn.\n */\n\n\nOAuth2Client.prototype.getToken = function (code, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    code: code,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    redirect_uri: this.redirectUri_,\n    grant_type: 'authorization_code'\n  };\n  this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function (err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = new Date().getTime() + tokens.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n/**\n * Refreshes the access token.\n * @param {string} refresh_token Existing refresh token.\n * @param {function=} opt_callback Optional callback.\n * @private\n */\n\n\nOAuth2Client.prototype.refreshToken_ = function (refresh_token, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    refresh_token: refresh_token,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    grant_type: 'refresh_token'\n  }; // request for new token\n\n  return this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function (err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = new Date().getTime() + tokens.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n/**\n * Retrieves the access token using refresh token\n *\n * @deprecated use getRequestMetadata instead.\n * @param {function} callback callback\n */\n\n\nOAuth2Client.prototype.refreshAccessToken = function (callback) {\n  var that = this;\n\n  if (!this.credentials.refresh_token) {\n    callback(new Error('No refresh token is set.'), null);\n    return;\n  }\n\n  this.refreshToken_(this.credentials.refresh_token, function (err, result, response) {\n    if (err) {\n      callback(err, null, response);\n    } else {\n      var tokens = result;\n      tokens.refresh_token = that.credentials.refresh_token;\n      that.credentials = tokens;\n      callback(null, that.credentials, response);\n    }\n  });\n};\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {function} callback Callback to call with the access token\n */\n\n\nOAuth2Client.prototype.getAccessToken = function (callback) {\n  var credentials = this.credentials;\n  var expiryDate = credentials.expiry_date; // if no expiry time, assume it's not expired\n\n  var isTokenExpired = expiryDate ? expiryDate <= new Date().getTime() : false;\n\n  if (!credentials.access_token && !credentials.refresh_token) {\n    return callback(new Error('No access or refresh token is set.'), null);\n  }\n\n  var shouldRefresh = !credentials.access_token || isTokenExpired;\n\n  if (shouldRefresh && credentials.refresh_token) {\n    if (!this.credentials.refresh_token) {\n      return callback(new Error('No refresh token is set.'), null);\n    }\n\n    this.refreshAccessToken(function (err, tokens, response) {\n      if (err) {\n        return callback(err, null, response);\n      }\n\n      if (!tokens || tokens && !tokens.access_token) {\n        return callback(new Error('Could not refresh access token.'), null, response);\n      }\n\n      return callback(null, tokens.access_token, response);\n    });\n  } else {\n    return callback(null, credentials.access_token, null);\n  }\n};\n/**\n * getRequestMetadata obtains auth metadata to be used by requests.\n *\n * getRequestMetadata is the main authentication interface.  It takes an\n * optional uri which when present is the endpoint being accessed, and a\n * callback func(err, metadata_obj, response) where metadata_obj contains\n * authorization metadata fields and response is an optional response object.\n *\n * In OAuth2Client, metadata_obj has the form.\n *\n * {Authorization: 'Bearer <access_token_value>'}\n *\n * @param {string} opt_uri the Uri being authorized\n * @param {function} metadataCb the func described above\n */\n\n\nOAuth2Client.prototype.getRequestMetadata = function (opt_uri, metadataCb) {\n  var that = this;\n  var thisCreds = this.credentials;\n\n  if (!thisCreds.access_token && !thisCreds.refresh_token) {\n    return metadataCb(new Error('No access or refresh token is set.'), null);\n  } // if no expiry time, assume it's not expired\n\n\n  var expiryDate = thisCreds.expiry_date;\n  var isTokenExpired = expiryDate ? expiryDate <= new Date().getTime() : false;\n\n  if (thisCreds.access_token && !isTokenExpired) {\n    thisCreds.token_type = thisCreds.token_type || 'Bearer';\n    var headers = {\n      'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token\n    };\n    return metadataCb(null, headers, null);\n  }\n\n  return this.refreshToken_(thisCreds.refresh_token, function (err, tokens, response) {\n    if (err) {\n      return metadataCb(err, null, response);\n    } else {\n      if (!tokens || tokens && !tokens.access_token) {\n        return metadataCb(new Error('Could not refresh access token.'), null, response);\n      }\n\n      var credentials = that.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      that.credentials = tokens;\n      var headers = {\n        'Authorization': credentials.token_type + ' ' + tokens.access_token\n      };\n      return metadataCb(err, headers, response);\n    }\n  });\n};\n/**\n * Revokes the access given to token.\n * @param {string} token The existing token to be revoked.\n * @param {function=} opt_callback Optional callback fn.\n */\n\n\nOAuth2Client.prototype.revokeToken = function (token, opt_callback) {\n  this.transporter.request({\n    uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' + querystring.stringify({\n      token: token\n    }),\n    json: true\n  }, opt_callback);\n};\n/**\n * Revokes access token and clears the credentials object\n * @param  {Function=} callback callback\n */\n\n\nOAuth2Client.prototype.revokeCredentials = function (callback) {\n  var token = this.credentials.access_token;\n  this.credentials = {};\n\n  if (token) {\n    this.revokeToken(token, callback);\n  } else {\n    callback(new Error('No access token to revoke.'), null);\n  }\n};\n/**\n * Provides a request implementation with OAuth 2.0 flow.\n * If credentials have a refresh_token, in cases of HTTP\n * 401 and 403 responses, it automatically asks for a new\n * access token and replays the unsuccessful request.\n * @param {object} opts Request options.\n * @param {function} callback callback.\n * @return {Request} Request object\n */\n\n\nOAuth2Client.prototype.request = function (opts, callback) {\n  /* jshint latedef:false */\n  var that = this; // Callbacks will close over this to ensure that we only retry once\n\n  var retry = true; // Hook the callback routine to call the _postRequest method.\n\n  var postRequestCb = function (err, body, resp) {\n    var statusCode = resp && resp.statusCode; // Automatically retry 401 and 403 responses\n    // if err is set and is unrelated to response\n    // then getting credentials failed, and retrying won't help\n\n    if (retry && (statusCode === 401 || statusCode === 403) && (!err || err.code === statusCode)) {\n      /* It only makes sense to retry once, because the retry is intended to\n       * handle expiration-related failures. If refreshing the token does not\n       * fix the failure, then refreshing again probably won't help */\n      retry = false; // Force token refresh\n\n      that.refreshAccessToken(function () {\n        that.getRequestMetadata(unusedUri, authCb);\n      });\n    } else {\n      that._postRequest(err, body, resp, callback);\n    }\n  };\n\n  var authCb = function (err, headers, response) {\n    if (err) {\n      postRequestCb(err, null, response);\n    } else {\n      if (headers) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = headers.Authorization;\n      }\n\n      return that._makeRequest(opts, postRequestCb);\n    }\n  };\n\n  var unusedUri = null;\n  return this.getRequestMetadata(unusedUri, authCb);\n};\n/**\n * Makes a request without paying attention to refreshing or anything\n * Assumes that all credentials are set correctly.\n * @param  {object}   opts     Options for request\n * @param  {Function} callback callback function\n * @return {Request}           The request object created\n */\n\n\nOAuth2Client.prototype._makeRequest = function (opts, callback) {\n  return this.transporter.request(opts, callback);\n};\n/**\n * Allows inheriting classes to inspect and alter the request result.\n * @param {object} err Error result.\n * @param {object} result The result.\n * @param {object} result The HTTP response.\n * @param {Function} callback The callback.\n * @private\n */\n\n\nOAuth2Client.prototype._postRequest = function (err, result, response, callback) {\n  callback(err, result, response);\n};\n/**\n * Verify id token is token by checking the certs and audience\n * @param {string} idToken ID Token.\n * @param {(string|Array.<string>)} audience The audience to verify against the ID Token\n * @param {function=} callback Callback supplying GoogleLogin if successful\n */\n\n\nOAuth2Client.prototype.verifyIdToken = function (idToken, audience, callback) {\n  if (!idToken || !callback) {\n    throw new Error('The verifyIdToken method requires both ' + 'an ID Token and a callback method');\n  }\n\n  this.getFederatedSignonCerts(function (err, certs) {\n    if (err) {\n      callback(err, null);\n    }\n\n    var login;\n\n    try {\n      login = this.verifySignedJwtWithCerts(idToken, certs, audience, OAuth2Client.ISSUERS_);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, login);\n  }.bind(this));\n};\n/**\n * Gets federated sign-on certificates to use for verifying identity tokens.\n * Returns certs as array structure, where keys are key ids, and values\n * are PEM encoded certificates.\n * @param {function=} callback Callback supplying the certificates\n */\n\n\nOAuth2Client.prototype.getFederatedSignonCerts = function (callback) {\n  var nowTime = new Date().getTime();\n\n  if (certificateExpiry && nowTime < certificateExpiry.getTime()) {\n    callback(null, certificateCache);\n    return;\n  }\n\n  this.transporter.request({\n    method: 'GET',\n    uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,\n    json: true\n  }, function (err, body, response) {\n    if (err) {\n      callback('Failed to retrieve verification certificates: ' + err, null, response);\n      return;\n    }\n\n    var cacheControl = response.headers['cache-control'];\n    var cacheAge = -1;\n\n    if (cacheControl) {\n      var pattern = new RegExp('max-age=([0-9]*)');\n      var regexResult = pattern.exec(cacheControl);\n\n      if (regexResult.length === 2) {\n        // Cache results with max-age (in seconds)\n        cacheAge = regexResult[1] * 1000; // milliseconds\n      }\n    }\n\n    var now = new Date();\n    certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    certificateCache = body;\n    callback(null, body, response);\n  });\n};\n/**\n * Verify the id token is signed with the correct certificate\n * and is from the correct audience.\n * @param {string} jwt The jwt to verify (The ID Token in this case).\n * @param {array} certs The array of certs to test the jwt against.\n * @param {(string|Array.<string>)} requiredAudience The audience to test the jwt against.\n * @param {array} issuers The allowed issuers of the jwt (Optional).\n * @param {string} maxExpiry The max expiry the certificate can be (Optional).\n * @return {LoginTicket} Returns a LoginTicket on verification.\n */\n\n\nOAuth2Client.prototype.verifySignedJwtWithCerts = function (jwt, certs, requiredAudience, issuers, maxExpiry) {\n  if (!maxExpiry) {\n    maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n  }\n\n  var segments = jwt.split('.');\n\n  if (segments.length !== 3) {\n    throw new Error('Wrong number of segments in token: ' + jwt);\n  }\n\n  var signed = segments[0] + '.' + segments[1];\n  var signature = segments[2];\n  var envelope, payload;\n\n  try {\n    envelope = JSON.parse(this.decodeBase64(segments[0]));\n  } catch (err) {}\n\n  if (!envelope) {\n    throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n  }\n\n  try {\n    payload = JSON.parse(this.decodeBase64(segments[1]));\n  } catch (err) {}\n\n  if (!payload) {\n    throw new Error('Can\\'t parse token payload: ' + segments[1]);\n  }\n\n  if (!certs.hasOwnProperty(envelope.kid)) {\n    // If this is not present, then there's no reason to attempt verification\n    throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n  }\n\n  var pem = certs[envelope.kid];\n  var pemVerifier = new PemVerifier();\n  var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n  if (!verified) {\n    throw new Error('Invalid token signature: ' + jwt);\n  }\n\n  if (!payload.iat) {\n    throw new Error('No issue time in token: ' + JSON.stringify(payload));\n  }\n\n  if (!payload.exp) {\n    throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n  }\n\n  var iat = parseInt(payload.iat, 10);\n  var exp = parseInt(payload.exp, 10);\n  var now = new Date().getTime() / 1000;\n\n  if (exp >= now + maxExpiry) {\n    throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n  }\n\n  var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n  var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n  if (now < earliest) {\n    throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n  }\n\n  if (now > latest) {\n    throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n  }\n\n  if (issuers && issuers.indexOf(payload.iss) < 0) {\n    throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n  } // Check the audience matches if we have one\n\n\n  if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n    var aud = payload.aud;\n    var audVerified = false; //If the requiredAudience is an array, check if it contains token audience\n\n    if (requiredAudience.constructor === Array) {\n      audVerified = requiredAudience.indexOf(aud) > -1;\n    } else {\n      audVerified = aud === requiredAudience;\n    }\n\n    if (!audVerified) {\n      throw new Error('Wrong recipient, payload audience != requiredAudience');\n    }\n  }\n\n  return new LoginTicket(envelope, payload);\n};\n/**\n * This is a utils method to decode a base64 string\n * @param {string} b64String The string to base64 decode\n * @return {string} The decoded string\n */\n\n\nOAuth2Client.prototype.decodeBase64 = function (b64String) {\n  var buffer = new Buffer(b64String, 'base64');\n  return buffer.toString('utf8');\n};\n/**\n * Export OAuth2Client.\n */\n\n\nmodule.exports = OAuth2Client;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/google-auto-auth/node_modules/google-auth-library/lib/auth/oauth2client.js"],"names":["AuthClient","require","LoginTicket","noop","PemVerifier","querystring","util","certificateCache","certificateExpiry","OAuth2Client","clientId","clientSecret","redirectUri","opt_opts","super_","call","clientId_","clientSecret_","redirectUri_","opts","credentials","inherits","GOOGLE_OAUTH2_AUTH_BASE_URL_","GOOGLE_OAUTH2_TOKEN_URL_","GOOGLE_OAUTH2_REVOKE_URL_","GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_","CLOCK_SKEW_SECS_","MAX_TOKEN_LIFETIME_SECS_","ISSUERS_","prototype","generateAuthUrl","response_type","client_id","redirect_uri","scope","Array","join","rootUrl","authBaseUrl","stringify","getToken","code","opt_callback","uri","tokenUrl","values","client_secret","grant_type","transporter","request","method","form","json","err","tokens","response","expires_in","expiry_date","Date","getTime","done","refreshToken_","refresh_token","refreshAccessToken","callback","that","Error","result","getAccessToken","expiryDate","isTokenExpired","access_token","shouldRefresh","getRequestMetadata","opt_uri","metadataCb","thisCreds","token_type","headers","revokeToken","token","revokeCredentials","retry","postRequestCb","body","resp","statusCode","unusedUri","authCb","_postRequest","Authorization","_makeRequest","verifyIdToken","idToken","audience","getFederatedSignonCerts","certs","login","verifySignedJwtWithCerts","bind","nowTime","cacheControl","cacheAge","pattern","RegExp","regexResult","exec","length","now","jwt","requiredAudience","issuers","maxExpiry","segments","split","signed","signature","envelope","payload","JSON","parse","decodeBase64","hasOwnProperty","kid","pem","pemVerifier","verified","verify","iat","exp","parseInt","earliest","latest","indexOf","iss","aud","audVerified","constructor","b64String","buffer","Buffer","toString","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar AuthClient = require('./authclient.js');\nvar LoginTicket = require('./loginticket.js');\nvar noop = require('lodash.noop');\nvar PemVerifier = require('./../pemverifier.js');\nvar querystring = require('querystring');\nvar util = require('util');\n\nvar certificateCache = null;\nvar certificateExpiry = null;\n\n/**\n * Handles OAuth2 flow for Google APIs.\n *\n * @param {string} clientId The authentication client ID.\n * @param {string} clientSecret The authentication client secret.\n * @param {string} redirectUri The URI to redirect to after completing the auth request.\n * @param {Object} opt_opts optional options for overriding the given parameters.\n * @constructor\n */\nfunction OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) {\n  OAuth2Client.super_.call(this);\n\n  this.clientId_ = clientId;\n  this.clientSecret_ = clientSecret;\n  this.redirectUri_ = redirectUri;\n  this.opts = opt_opts || {};\n  this.credentials = {};\n}\n\n/**\n * Inherit from AuthClient.\n */\nutil.inherits(OAuth2Client, AuthClient);\n\n/**\n * The base URL for auth endpoints.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ =\n  'https://accounts.google.com/o/oauth2/auth';\n\n/**\n * The base endpoint for token retrieval.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ =\n  'https://accounts.google.com/o/oauth2/token';\n\n/**\n * The base endpoint to revoke tokens.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ =\n  'https://accounts.google.com/o/oauth2/revoke';\n\n/**\n * Google Sign on certificates.\n * @const\n * @private\n */\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ =\n  'https://www.googleapis.com/oauth2/v1/certs';\n\n/**\n * Clock skew - five minutes in seconds\n * @const\n * @private\n */\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n\n/**\n * Max Token Lifetime is one day in seconds\n * @const\n * @private\n */\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n\n/**\n * The allowed oauth token issuers.\n * @const\n * @private\n */\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n\n/**\n * Generates URL for consent page landing.\n * @param {object=} opt_opts Options.\n * @return {string} URL to consent page.\n */\nOAuth2Client.prototype.generateAuthUrl = function(opt_opts) {\n  var opts = opt_opts || {};\n  opts.response_type = opts.response_type || 'code';\n  opts.client_id = opts.client_id || this.clientId_;\n  opts.redirect_uri = opts.redirect_uri || this.redirectUri_;\n\n  // Allow scopes to be passed either as array or a string\n  if (opts.scope instanceof Array) {\n    opts.scope = opts.scope.join(' ');\n  }\n\n  var rootUrl = this.opts.authBaseUrl ||\n    OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n\n  return rootUrl + '?' + querystring.stringify(opts);\n};\n\n/**\n * Gets the access token for the given code.\n * @param {string} code The authorization code.\n * @param {function=} opt_callback Optional callback fn.\n */\nOAuth2Client.prototype.getToken = function(code, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    code: code,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    redirect_uri: this.redirectUri_,\n    grant_type: 'authorization_code'\n  };\n\n  this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function(err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));\n      delete tokens.expires_in;\n    }\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n\n/**\n * Refreshes the access token.\n * @param {string} refresh_token Existing refresh token.\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nOAuth2Client.prototype.refreshToken_ = function(refresh_token, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    refresh_token: refresh_token,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    grant_type: 'refresh_token'\n  };\n\n  // request for new token\n  return this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function(err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = ((new Date()).getTime() + (tokens.expires_in * 1000));\n      delete tokens.expires_in;\n    }\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n\n/**\n * Retrieves the access token using refresh token\n *\n * @deprecated use getRequestMetadata instead.\n * @param {function} callback callback\n */\nOAuth2Client.prototype.refreshAccessToken = function(callback) {\n  var that = this;\n\n  if (!this.credentials.refresh_token) {\n    callback(new Error('No refresh token is set.'), null);\n    return;\n  }\n\n  this.refreshToken_(this.credentials.refresh_token, function(err, result, response) {\n    if (err) {\n      callback(err, null, response);\n    } else {\n      var tokens = result;\n      tokens.refresh_token = that.credentials.refresh_token;\n      that.credentials = tokens;\n      callback(null, that.credentials, response);\n    }\n  });\n};\n\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {function} callback Callback to call with the access token\n */\nOAuth2Client.prototype.getAccessToken = function(callback) {\n  var credentials = this.credentials;\n  var expiryDate = credentials.expiry_date;\n\n  // if no expiry time, assume it's not expired\n  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;\n\n  if (!credentials.access_token && !credentials.refresh_token) {\n    return callback(new Error('No access or refresh token is set.'), null);\n  }\n\n  var shouldRefresh = !credentials.access_token || isTokenExpired;\n  if (shouldRefresh && credentials.refresh_token) {\n    if (!this.credentials.refresh_token) {\n      return callback(new Error('No refresh token is set.'), null);\n    }\n\n    this.refreshAccessToken(function(err, tokens, response) {\n      if (err) {\n        return callback(err, null, response);\n      }\n      if (!tokens || (tokens && !tokens.access_token)) {\n        return callback(new Error('Could not refresh access token.'), null, response);\n      }\n      return callback(null, tokens.access_token, response);\n    });\n  } else {\n    return callback(null, credentials.access_token, null);\n  }\n};\n\n/**\n * getRequestMetadata obtains auth metadata to be used by requests.\n *\n * getRequestMetadata is the main authentication interface.  It takes an\n * optional uri which when present is the endpoint being accessed, and a\n * callback func(err, metadata_obj, response) where metadata_obj contains\n * authorization metadata fields and response is an optional response object.\n *\n * In OAuth2Client, metadata_obj has the form.\n *\n * {Authorization: 'Bearer <access_token_value>'}\n *\n * @param {string} opt_uri the Uri being authorized\n * @param {function} metadataCb the func described above\n */\nOAuth2Client.prototype.getRequestMetadata = function(opt_uri, metadataCb) {\n  var that = this;\n  var thisCreds = this.credentials;\n\n  if (!thisCreds.access_token && !thisCreds.refresh_token) {\n    return metadataCb(new Error('No access or refresh token is set.'), null);\n  }\n\n  // if no expiry time, assume it's not expired\n  var expiryDate = thisCreds.expiry_date;\n  var isTokenExpired = expiryDate ? expiryDate <= (new Date()).getTime() : false;\n\n  if (thisCreds.access_token && !isTokenExpired) {\n    thisCreds.token_type = thisCreds.token_type || 'Bearer';\n    var headers = {'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token };\n    return metadataCb(null, headers , null);\n  }\n\n  return this.refreshToken_(thisCreds.refresh_token, function(err, tokens, response) {\n    if (err) {\n      return metadataCb(err, null, response);\n    } else {\n      if (!tokens || (tokens && !tokens.access_token)) {\n        return metadataCb(new Error('Could not refresh access token.'), null, response);\n      }\n\n      var credentials = that.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      that.credentials = tokens;\n      var headers = {'Authorization': credentials.token_type + ' ' + tokens.access_token };\n      return metadataCb(err, headers , response);\n    }\n  });\n};\n\n/**\n * Revokes the access given to token.\n * @param {string} token The existing token to be revoked.\n * @param {function=} opt_callback Optional callback fn.\n */\nOAuth2Client.prototype.revokeToken = function(token, opt_callback) {\n  this.transporter.request({\n    uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ +\n      '?' + querystring.stringify({ token: token }),\n    json: true\n  }, opt_callback);\n};\n\n/**\n * Revokes access token and clears the credentials object\n * @param  {Function=} callback callback\n */\nOAuth2Client.prototype.revokeCredentials = function(callback) {\n  var token = this.credentials.access_token;\n  this.credentials = {};\n  if (token) {\n    this.revokeToken(token, callback);\n  } else {\n    callback(new Error('No access token to revoke.'), null);\n  }\n};\n\n/**\n * Provides a request implementation with OAuth 2.0 flow.\n * If credentials have a refresh_token, in cases of HTTP\n * 401 and 403 responses, it automatically asks for a new\n * access token and replays the unsuccessful request.\n * @param {object} opts Request options.\n * @param {function} callback callback.\n * @return {Request} Request object\n */\nOAuth2Client.prototype.request = function(opts, callback) {\n  /* jshint latedef:false */\n  var that = this;\n\n  // Callbacks will close over this to ensure that we only retry once\n  var retry = true;\n\n  // Hook the callback routine to call the _postRequest method.\n  var postRequestCb = function(err, body, resp) {\n    var statusCode = resp && resp.statusCode;\n    // Automatically retry 401 and 403 responses\n    // if err is set and is unrelated to response\n    // then getting credentials failed, and retrying won't help\n    if (retry && (statusCode === 401 || statusCode === 403) &&\n        (!err || err.code === statusCode)) {\n      /* It only makes sense to retry once, because the retry is intended to\n       * handle expiration-related failures. If refreshing the token does not\n       * fix the failure, then refreshing again probably won't help */\n      retry = false;\n      // Force token refresh\n      that.refreshAccessToken(function() {\n        that.getRequestMetadata(unusedUri, authCb);\n      });\n    } else {\n      that._postRequest(err, body, resp, callback);\n    }\n  };\n\n  var authCb = function(err, headers, response) {\n    if (err) {\n      postRequestCb(err, null, response);\n    } else {\n      if (headers) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = headers.Authorization;\n      }\n      return that._makeRequest(opts, postRequestCb);\n    }\n  };\n\n  var unusedUri = null;\n  return this.getRequestMetadata(unusedUri, authCb);\n};\n\n/**\n * Makes a request without paying attention to refreshing or anything\n * Assumes that all credentials are set correctly.\n * @param  {object}   opts     Options for request\n * @param  {Function} callback callback function\n * @return {Request}           The request object created\n */\nOAuth2Client.prototype._makeRequest = function(opts, callback) {\n  return this.transporter.request(opts, callback);\n};\n\n/**\n * Allows inheriting classes to inspect and alter the request result.\n * @param {object} err Error result.\n * @param {object} result The result.\n * @param {object} result The HTTP response.\n * @param {Function} callback The callback.\n * @private\n */\nOAuth2Client.prototype._postRequest = function(err, result, response, callback) {\n  callback(err, result, response);\n};\n\n/**\n * Verify id token is token by checking the certs and audience\n * @param {string} idToken ID Token.\n * @param {(string|Array.<string>)} audience The audience to verify against the ID Token\n * @param {function=} callback Callback supplying GoogleLogin if successful\n */\nOAuth2Client.prototype.verifyIdToken = function(idToken, audience, callback) {\n  if (!idToken || !callback) {\n    throw new Error('The verifyIdToken method requires both ' +\n      'an ID Token and a callback method');\n  }\n\n  this.getFederatedSignonCerts(function(err, certs) {\n    if (err) {\n      callback(err, null);\n    }\n    var login;\n    try {\n      login = this.verifySignedJwtWithCerts(idToken, certs, audience,\n        OAuth2Client.ISSUERS_);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, login);\n  }.bind(this));\n};\n\n/**\n * Gets federated sign-on certificates to use for verifying identity tokens.\n * Returns certs as array structure, where keys are key ids, and values\n * are PEM encoded certificates.\n * @param {function=} callback Callback supplying the certificates\n */\nOAuth2Client.prototype.getFederatedSignonCerts = function(callback) {\n  var nowTime = (new Date()).getTime();\n  if (certificateExpiry && (nowTime < certificateExpiry.getTime())) {\n    callback(null, certificateCache);\n    return;\n  }\n\n  this.transporter.request({\n    method: 'GET',\n    uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,\n    json: true\n  }, function(err, body, response) {\n    if (err) {\n      callback('Failed to retrieve verification certificates: ' + err, null, response);\n      return;\n    }\n\n    var cacheControl = response.headers['cache-control'];\n    var cacheAge = -1;\n    if (cacheControl) {\n      var pattern = new RegExp('max-age=([0-9]*)');\n      var regexResult = pattern.exec(cacheControl);\n      if (regexResult.length === 2) {\n        // Cache results with max-age (in seconds)\n        cacheAge = regexResult[1] * 1000; // milliseconds\n      }\n    }\n\n    var now = new Date();\n    certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    certificateCache = body;\n    callback(null, body, response);\n  });\n};\n\n/**\n * Verify the id token is signed with the correct certificate\n * and is from the correct audience.\n * @param {string} jwt The jwt to verify (The ID Token in this case).\n * @param {array} certs The array of certs to test the jwt against.\n * @param {(string|Array.<string>)} requiredAudience The audience to test the jwt against.\n * @param {array} issuers The allowed issuers of the jwt (Optional).\n * @param {string} maxExpiry The max expiry the certificate can be (Optional).\n * @return {LoginTicket} Returns a LoginTicket on verification.\n */\nOAuth2Client.prototype.verifySignedJwtWithCerts =\n  function(jwt, certs, requiredAudience, issuers, maxExpiry) {\n\n    if (!maxExpiry) {\n      maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n    }\n\n    var segments = jwt.split('.');\n    if (segments.length !== 3) {\n      throw new Error('Wrong number of segments in token: ' + jwt);\n    }\n    var signed = segments[0] + '.' + segments[1];\n\n    var signature = segments[2];\n\n    var envelope, payload;\n    try {\n      envelope = JSON.parse(this.decodeBase64(segments[0]));\n    } catch (err) { }\n\n    if (!envelope) {\n      throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n    }\n\n    try {\n      payload = JSON.parse(this.decodeBase64(segments[1]));\n    } catch (err) { }\n    if (!payload) {\n      throw new Error('Can\\'t parse token payload: ' + segments[1]);\n    }\n\n    if (!certs.hasOwnProperty(envelope.kid)) {\n      // If this is not present, then there's no reason to attempt verification\n      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n    }\n    var pem = certs[envelope.kid];\n    var pemVerifier = new PemVerifier();\n    var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n    if (!verified) {\n      throw new Error('Invalid token signature: ' + jwt);\n    }\n\n    if (!payload.iat) {\n      throw new Error('No issue time in token: ' + JSON.stringify(payload));\n    }\n\n    if (!payload.exp) {\n      throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n    }\n\n    var iat = parseInt(payload.iat, 10);\n    var exp = parseInt(payload.exp, 10);\n    var now = new Date().getTime() / 1000;\n\n    if (exp >= now + maxExpiry) {\n      throw new Error('Expiration time too far in future: ' +\n        JSON.stringify(payload));\n    }\n\n    var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now < earliest) {\n      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' +\n        JSON.stringify(payload));\n    }\n\n    if (now > latest) {\n      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' +\n        JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss) < 0) {\n      throw new Error('Invalid issuer, expected one of [' + issuers +\n          '], but got ' + payload.iss);\n    }\n\n    // Check the audience matches if we have one\n    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n      var aud = payload.aud;\n      var audVerified = false;\n      //If the requiredAudience is an array, check if it contains token audience\n      if(requiredAudience.constructor === Array)\n      {\n          audVerified = (requiredAudience.indexOf(aud) > -1);\n      }\n      else{\n          audVerified = (aud === requiredAudience);\n      }\n      if (!audVerified) {\n         throw new Error('Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n\n    return new LoginTicket(envelope, payload);\n  };\n\n/**\n * This is a utils method to decode a base64 string\n * @param {string} b64String The string to base64 decode\n * @return {string} The decoded string\n */\nOAuth2Client.prototype.decodeBase64 = function(b64String) {\n  var buffer = new Buffer(b64String, 'base64');\n  return buffer.toString('utf8');\n};\n\n/**\n * Export OAuth2Client.\n */\nmodule.exports = OAuth2Client;\n"]},"metadata":{},"sourceType":"script"}