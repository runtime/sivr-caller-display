{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst lodash_1 = require(\"lodash\");\n\nconst proxy_1 = require(\"./proxy\");\n\nconst getProjectId = require(\"../getProjectId\");\n\nconst logger = require(\"../logger\");\n\nconst api_1 = require(\"../api\");\n\nconst cloudRunCache = {};\n\nfunction getCloudRunUrl(rewrite, projectId) {\n  const alreadyFetched = cloudRunCache[`${rewrite.run.region}/${rewrite.run.serviceId}`];\n\n  if (alreadyFetched) {\n    return Promise.resolve(alreadyFetched);\n  }\n\n  const path = `/v1alpha1/projects/${projectId}/locations/${rewrite.run.region || \"us-central1\"}/services/${rewrite.run.serviceId}`;\n  logger.info(`[hosting] Looking up Cloud Run service \"${path}\" for its URL`);\n  return api_1.request(\"GET\", path, {\n    origin: api_1.cloudRunApiOrigin,\n    auth: true\n  }).then(res => {\n    const url = lodash_1.get(res, \"body.status.address.hostname\");\n\n    if (!url) {\n      return Promise.reject(\"Cloud Run URL doesn't exist in response.\");\n    }\n\n    cloudRunCache[`${rewrite.run.region}/${rewrite.run.serviceId}`] = url;\n    return url;\n  }).catch(err => {\n    const errInfo = `error looking up URL for Cloud Run service: ${err}`;\n    return Promise.reject(errInfo);\n  });\n}\n\nfunction default_1(options) {\n  return rewrite => __awaiter(this, void 0, void 0, function* () {\n    if (!rewrite.run) {\n      return proxy_1.errorRequestHandler('Cloud Run rewrites must have a valid \"run\" field.');\n    }\n\n    if (!rewrite.run.serviceId) {\n      return proxy_1.errorRequestHandler(\"Cloud Run rewrites must supply a service ID.\");\n    }\n\n    if (!rewrite.run.region) {\n      rewrite.run.region = \"us-central1\";\n    }\n\n    logger.info(`[hosting] Cloud Run rewrite ${JSON.stringify(rewrite)} triggered`);\n    const textIdentifier = `Cloud Run service \"${rewrite.run.serviceId}\" for region \"${rewrite.run.region}\"`;\n    return getCloudRunUrl(rewrite, getProjectId(options, false)).then(url => proxy_1.proxyRequestHandler(url, textIdentifier)).catch(proxy_1.errorRequestHandler);\n  });\n}\n\nexports.default = default_1;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/hosting/cloudRunProxy.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","lodash_1","require","proxy_1","getProjectId","logger","api_1","cloudRunCache","getCloudRunUrl","rewrite","projectId","alreadyFetched","run","region","serviceId","path","info","request","origin","cloudRunApiOrigin","auth","res","url","get","catch","err","errInfo","default_1","options","errorRequestHandler","JSON","stringify","textIdentifier","proxyRequestHandler","default"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lodash_1 = require(\"lodash\");\nconst proxy_1 = require(\"./proxy\");\nconst getProjectId = require(\"../getProjectId\");\nconst logger = require(\"../logger\");\nconst api_1 = require(\"../api\");\nconst cloudRunCache = {};\nfunction getCloudRunUrl(rewrite, projectId) {\n    const alreadyFetched = cloudRunCache[`${rewrite.run.region}/${rewrite.run.serviceId}`];\n    if (alreadyFetched) {\n        return Promise.resolve(alreadyFetched);\n    }\n    const path = `/v1alpha1/projects/${projectId}/locations/${rewrite.run.region ||\n        \"us-central1\"}/services/${rewrite.run.serviceId}`;\n    logger.info(`[hosting] Looking up Cloud Run service \"${path}\" for its URL`);\n    return api_1.request(\"GET\", path, { origin: api_1.cloudRunApiOrigin, auth: true })\n        .then((res) => {\n        const url = lodash_1.get(res, \"body.status.address.hostname\");\n        if (!url) {\n            return Promise.reject(\"Cloud Run URL doesn't exist in response.\");\n        }\n        cloudRunCache[`${rewrite.run.region}/${rewrite.run.serviceId}`] = url;\n        return url;\n    })\n        .catch((err) => {\n        const errInfo = `error looking up URL for Cloud Run service: ${err}`;\n        return Promise.reject(errInfo);\n    });\n}\nfunction default_1(options) {\n    return (rewrite) => __awaiter(this, void 0, void 0, function* () {\n        if (!rewrite.run) {\n            return proxy_1.errorRequestHandler('Cloud Run rewrites must have a valid \"run\" field.');\n        }\n        if (!rewrite.run.serviceId) {\n            return proxy_1.errorRequestHandler(\"Cloud Run rewrites must supply a service ID.\");\n        }\n        if (!rewrite.run.region) {\n            rewrite.run.region = \"us-central1\";\n        }\n        logger.info(`[hosting] Cloud Run rewrite ${JSON.stringify(rewrite)} triggered`);\n        const textIdentifier = `Cloud Run service \"${rewrite.run.serviceId}\" for region \"${rewrite.run.region}\"`;\n        return getCloudRunUrl(rewrite, getProjectId(options, false))\n            .then((url) => proxy_1.proxyRequestHandler(url, textIdentifier))\n            .catch(proxy_1.errorRequestHandler);\n    });\n}\nexports.default = default_1;\n"]},"metadata":{},"sourceType":"script"}