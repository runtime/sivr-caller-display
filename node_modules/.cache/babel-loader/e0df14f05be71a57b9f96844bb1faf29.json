{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst _require = require('stream'),\n      Readable = _require.Readable;\n\nconst sysPath = require('path');\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const root = opts.root,\n          type = opts.type;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    try {\n      this.parents = [this._exploreDir(root, 1)];\n    } catch (error) {\n      this.destroy(error);\n    }\n\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const _ref = this.parent || {},\n              path = _ref.path,\n              depth = _ref.depth,\n              _ref$files = _ref.files,\n              files = _ref$files === void 0 ? [] : _ref$files;\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this._isDirAndMatchesFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if (this._isFileAndMatchesFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    const basename = this._isDirent ? dirent.name : dirent;\n    const fullPath = sysPath.resolve(sysPath.join(path, basename));\n    const entry = {\n      path: sysPath.relative(this._root, fullPath),\n      fullPath,\n      basename\n    };\n\n    try {\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      throw err;\n    }\n  }\n\n  _isDirAndMatchesFilter(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    return stats && stats.isDirectory() && this._directoryFilter(entry);\n  }\n\n  _isFileAndMatchesFilter(entry) {\n    const stats = entry && entry[this._statsProp];\n    const isFileType = stats && (this._wantsEverything && !stats.isDirectory() || stats.isFile() || stats.isSymbolicLink());\n    return isFileType && this._fileFilter(entry);\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/node_modules/readdirp/index.js"],"names":["fs","require","Readable","sysPath","promisify","picomatch","readdir","stat","lstat","BANG","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","slice","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","process","platform","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","destroy","reading","parent","_read","batch","destroyed","files","splice","map","dirent","_formatEntry","Promise","all","_isDirAndMatchesFilter","fullPath","_isFileAndMatchesFilter","pop","_onError","name","join","relative","err","emit","stats","isDirectory","isFileType","isFile","isSymbolicLink","readdirp","entryType","Error","TypeError","readdirpPromise","reject","on","promise","default","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    try {\n      this.parents = [this._exploreDir(root, 1)];\n    } catch (error) {\n      this.destroy(error);\n    }\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this._isDirAndMatchesFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if (this._isFileAndMatchesFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path) {\n    const basename = this._isDirent ? dirent.name : dirent;\n    const fullPath = sysPath.resolve(sysPath.join(path, basename));\n    const entry = {path: sysPath.relative(this._root, fullPath), fullPath, basename};\n    try {\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      throw err;\n    }\n  }\n\n  _isDirAndMatchesFilter(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    return stats && stats.isDirectory() && this._directoryFilter(entry);\n  }\n\n  _isFileAndMatchesFilter(entry) {\n    const stats = entry && entry[this._statsProp];\n    const isFileType = stats && (\n      (this._wantsEverything && !stats.isDirectory()) ||\n      (stats.isFile() || stats.isSymbolicLink())\n    );\n    return isFileType && this._fileFilter(entry);\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n"]},"metadata":{},"sourceType":"script"}