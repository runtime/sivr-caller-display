{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\n\nconst apiCaller_1 = require(\"./apiCaller\");\n\nconst retries_1 = require(\"./normalCalls/retries\");\n\nconst timeout_1 = require(\"./normalCalls/timeout\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\n\n\nfunction createApiCall(func, settings, descriptor) {\n  // we want to be able to accept both promise resolving to a function and a\n  // function. Currently client librares are only calling this method with a\n  // promise, but it will change.\n  const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func; // the following apiCaller will be used for all calls of this function...\n\n  const apiCaller = apiCaller_1.createAPICaller(settings, descriptor);\n  return (request, callOptions, callback) => {\n    const thisSettings = settings.merge(callOptions);\n    let currentApiCaller = apiCaller; // special case: if bundling is disabled for this one call,\n    // use default API caller instead\n\n    if (settings.isBundling && !thisSettings.isBundling) {\n      currentApiCaller = apiCaller_1.createAPICaller(settings, undefined);\n    }\n\n    const status = currentApiCaller.init(thisSettings, callback);\n    funcPromise.then(func => {\n      func = currentApiCaller.wrap(func);\n      const retry = thisSettings.retry;\n\n      if (retry && retry.retryCodes && retry.retryCodes.length > 0) {\n        return retries_1.retryable(func, thisSettings.retry, thisSettings.otherArgs);\n      }\n\n      return timeout_1.addTimeoutArg(func, thisSettings.timeout, thisSettings.otherArgs);\n    }).then(apiCall => {\n      currentApiCaller.call(apiCall, request, thisSettings, status);\n    }).catch(err => {\n      currentApiCaller.fail(status, err);\n    });\n    return currentApiCaller.result(status);\n  };\n}\n\nexports.createApiCall = createApiCall;","map":{"version":3,"sources":["../../src/createApiCall.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;;;AAIA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAUA,MAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;;;AAmBA,SAAgB,aAAhB,CACE,IADF,EAEE,QAFF,EAGE,UAHF,EAGyB;AAEvB;AACA;AACA;AACA,QAAM,WAAW,GAAG,OAAO,IAAP,KAAgB,UAAhB,GAA6B,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAA7B,GAAqD,IAAzE,CALuB,CAOvB;;AACA,QAAM,SAAS,GAAG,WAAA,CAAA,eAAA,CAAgB,QAAhB,EAA0B,UAA1B,CAAlB;AAEA,SAAO,CACL,OADK,EAEL,WAFK,EAGL,QAHK,KAIH;AACF,UAAM,YAAY,GAAG,QAAQ,CAAC,KAAT,CAAe,WAAf,CAArB;AAEA,QAAI,gBAAgB,GAAG,SAAvB,CAHE,CAIF;AACA;;AACA,QAAI,QAAQ,CAAC,UAAT,IAAuB,CAAC,YAAY,CAAC,UAAzC,EAAqD;AACnD,MAAA,gBAAgB,GAAG,WAAA,CAAA,eAAA,CAAgB,QAAhB,EAA0B,SAA1B,CAAnB;AACD;;AAED,UAAM,MAAM,GAAG,gBAAgB,CAAC,IAAjB,CAAsB,YAAtB,EAAoC,QAApC,CAAf;AACA,IAAA,WAAW,CACR,IADH,CACQ,IAAI,IAAG;AACX,MAAA,IAAI,GAAG,gBAAgB,CAAC,IAAjB,CAAsB,IAAtB,CAAP;AACA,YAAM,KAAK,GAAG,YAAY,CAAC,KAA3B;;AACA,UAAI,KAAK,IAAI,KAAK,CAAC,UAAf,IAA6B,KAAK,CAAC,UAAN,CAAiB,MAAjB,GAA0B,CAA3D,EAA8D;AAC5D,eAAO,SAAA,CAAA,SAAA,CACL,IADK,EAEL,YAAY,CAAC,KAFR,EAGL,YAAY,CAAC,SAHR,CAAP;AAKD;;AACD,aAAO,SAAA,CAAA,aAAA,CACL,IADK,EAEL,YAAY,CAAC,OAFR,EAGL,YAAY,CAAC,SAHR,CAAP;AAKD,KAhBH,EAiBG,IAjBH,CAiBQ,OAAO,IAAG;AACd,MAAA,gBAAgB,CAAC,IAAjB,CAAsB,OAAtB,EAA+B,OAA/B,EAAwC,YAAxC,EAAsD,MAAtD;AACD,KAnBH,EAoBG,KApBH,CAoBS,GAAG,IAAG;AACX,MAAA,gBAAgB,CAAC,IAAjB,CAAsB,MAAtB,EAA8B,GAA9B;AACD,KAtBH;AAuBA,WAAO,gBAAgB,CAAC,MAAjB,CAAwB,MAAxB,CAAP;AACD,GAvCD;AAwCD;;AArDD,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Provides function wrappers that implement page streaming and retrying.\n */\nconst apiCaller_1 = require(\"./apiCaller\");\nconst retries_1 = require(\"./normalCalls/retries\");\nconst timeout_1 = require(\"./normalCalls/timeout\");\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\nfunction createApiCall(func, settings, descriptor) {\n    // we want to be able to accept both promise resolving to a function and a\n    // function. Currently client librares are only calling this method with a\n    // promise, but it will change.\n    const funcPromise = typeof func === 'function' ? Promise.resolve(func) : func;\n    // the following apiCaller will be used for all calls of this function...\n    const apiCaller = apiCaller_1.createAPICaller(settings, descriptor);\n    return (request, callOptions, callback) => {\n        const thisSettings = settings.merge(callOptions);\n        let currentApiCaller = apiCaller;\n        // special case: if bundling is disabled for this one call,\n        // use default API caller instead\n        if (settings.isBundling && !thisSettings.isBundling) {\n            currentApiCaller = apiCaller_1.createAPICaller(settings, undefined);\n        }\n        const status = currentApiCaller.init(thisSettings, callback);\n        funcPromise\n            .then(func => {\n            func = currentApiCaller.wrap(func);\n            const retry = thisSettings.retry;\n            if (retry && retry.retryCodes && retry.retryCodes.length > 0) {\n                return retries_1.retryable(func, thisSettings.retry, thisSettings.otherArgs);\n            }\n            return timeout_1.addTimeoutArg(func, thisSettings.timeout, thisSettings.otherArgs);\n        })\n            .then(apiCall => {\n            currentApiCaller.call(apiCall, request, thisSettings, status);\n        })\n            .catch(err => {\n            currentApiCaller.fail(status, err);\n        });\n        return currentApiCaller.result(status);\n    };\n}\nexports.createApiCall = createApiCall;\n//# sourceMappingURL=createApiCall.js.map"]},"metadata":{},"sourceType":"script"}