{"ast":null,"code":"/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar Auth2Client = require('./oauth2client.js');\n\nvar gToken = require('gtoken');\n\nvar JWTAccess = require('./jwtaccess.js');\n\nvar noop = require('lodash.noop');\n\nvar util = require('util');\n/**\n * JWT service account credentials.\n *\n * Retrieve access token using gtoken.\n *\n * @param {string=} email service account email address.\n * @param {string=} keyFile path to private key file.\n * @param {string=} key value of key\n * @param {(string|array)=} scopes list of requested scopes or a single scope.\n * @param {string=} subject impersonated account's email address.\n * @constructor\n */\n\n\nfunction JWT(email, keyFile, key, scopes, subject) {\n  JWT.super_.call(this);\n  this.email = email;\n  this.keyFile = keyFile;\n  this.key = key;\n  this.scopes = scopes;\n  this.subject = subject;\n  this.gToken = gToken;\n  this.credentials = {\n    refresh_token: 'jwt-placeholder',\n    expiry_date: 1\n  };\n}\n/**\n * Inherit from Auth2Client.\n */\n\n\nutil.inherits(JWT, Auth2Client);\n/**\n * Creates a copy of the credential with the specified scopes.\n * @param {(string|array)=} scopes List of requested scopes or a single scope.\n * @return {object} The cloned instance.\n */\n\nJWT.prototype.createScoped = function (scopes) {\n  return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);\n};\n/**\n * Obtains the metadata to be sent with the request.\n *\n * @param {string} opt_uri the URI being authorized.\n * @param {function} metadataCb\n */\n\n\nJWT.prototype.getRequestMetadata = function (opt_uri, metadataCb) {\n  if (this.createScopedRequired() && opt_uri) {\n    // no scopes have been set, but a uri has been provided.  Use JWTAccess credentials.\n    var alt = new JWTAccess(this.email, this.key);\n    return alt.getRequestMetadata(opt_uri, metadataCb);\n  } else {\n    return JWT.super_.prototype.getRequestMetadata.call(this, opt_uri, metadataCb);\n  }\n};\n/**\n * Indicates whether the credential requires scopes to be created by calling createdScoped before\n * use.\n * @return {boolean} false if createScoped does not need to be called.\n */\n\n\nJWT.prototype.createScopedRequired = function () {\n  // If scopes is null, always return true.\n  if (this.scopes) {\n    // For arrays, check the array length.\n    if (this.scopes instanceof Array) {\n      return this.scopes.length === 0;\n    } // For others, convert to a string and check the length.\n\n\n    return String(this.scopes).length === 0;\n  }\n\n  return true;\n};\n/**\n * Get the initial access token using gToken.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWT.prototype.authorize = function (opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  that.refreshToken_(null, function (err, result) {\n    if (!err) {\n      that.credentials = result;\n      that.credentials.refresh_token = 'jwt-placeholder';\n      that.key = that.gtoken.key;\n      that.email = that.gtoken.iss;\n    }\n\n    done(err, result);\n  });\n};\n/**\n * Refreshes the access token.\n * @param {object=} ignored_\n * @param {function=} opt_callback Optional callback.\n * @private\n */\n\n\nJWT.prototype.refreshToken_ = function (ignored_, opt_callback) {\n  var done = opt_callback || noop;\n  return this._createGToken(function (err, gToken) {\n    if (err) {\n      return done(err);\n    } else {\n      return gToken.getToken(function (err, token) {\n        return done(err, {\n          access_token: token,\n          token_type: 'Bearer',\n          expiry_date: gToken.expires_at\n        });\n      });\n    }\n  });\n};\n/**\n * Create a JWT credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWT.prototype.fromJSON = function (json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!json) {\n    done(new Error('Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n\n  if (!json.client_email) {\n    done(new Error('The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n\n  if (!json.private_key) {\n    done(new Error('The incoming JSON object does not contain a private_key field'));\n    return;\n  } // Extract the relevant information from the json key file.\n\n\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n/**\n * Create a JWT credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWT.prototype.fromStream = function (stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!stream) {\n    process.nextTick(function () {\n      done(new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n/**\n * Creates the gToken instance if it has not been created already.\n * @param {function=} callback Callback.\n * @private\n */\n\n\nJWT.prototype._createGToken = function (callback) {\n  if (this.gtoken) {\n    return callback(null, this.gtoken);\n  } else {\n    this.gtoken = this.gToken({\n      iss: this.email,\n      sub: this.subject,\n      scope: this.scopes,\n      keyFile: this.keyFile,\n      key: this.key\n    });\n    return callback(null, this.gtoken);\n  }\n};\n/**\n * Export JWT.\n */\n\n\nmodule.exports = JWT;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/google-auto-auth/node_modules/google-auth-library/lib/auth/jwtclient.js"],"names":["Auth2Client","require","gToken","JWTAccess","noop","util","JWT","email","keyFile","key","scopes","subject","super_","call","credentials","refresh_token","expiry_date","inherits","prototype","createScoped","getRequestMetadata","opt_uri","metadataCb","createScopedRequired","alt","Array","length","String","authorize","opt_callback","that","done","refreshToken_","err","result","gtoken","iss","ignored_","_createGToken","getToken","token","access_token","token_type","expires_at","fromJSON","json","Error","client_email","private_key","projectId","project_id","fromStream","stream","process","nextTick","s","setEncoding","on","chunk","data","JSON","parse","callback","sub","scope","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA;;AAEA,IAAIA,WAAW,GAAGC,OAAO,CAAC,mBAAD,CAAzB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,gBAAD,CAAvB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAII,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAAlB;AAGA;;;;;;;;;;;;;;AAYA,SAASK,GAAT,CAAaC,KAAb,EAAoBC,OAApB,EAA6BC,GAA7B,EAAkCC,MAAlC,EAA0CC,OAA1C,EAAmD;AACjDL,EAAAA,GAAG,CAACM,MAAJ,CAAWC,IAAX,CAAgB,IAAhB;AACA,OAAKN,KAAL,GAAaA,KAAb;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKC,GAAL,GAAWA,GAAX;AACA,OAAKC,MAAL,GAAcA,MAAd;AACA,OAAKC,OAAL,GAAeA,OAAf;AACA,OAAKT,MAAL,GAAcA,MAAd;AAEA,OAAKY,WAAL,GAAmB;AACjBC,IAAAA,aAAa,EAAE,iBADE;AAEjBC,IAAAA,WAAW,EAAE;AAFI,GAAnB;AAID;AAED;;;;;AAGAX,IAAI,CAACY,QAAL,CAAcX,GAAd,EAAmBN,WAAnB;AAEA;;;;;;AAKAM,GAAG,CAACY,SAAJ,CAAcC,YAAd,GAA6B,UAAST,MAAT,EAAiB;AAC5C,SAAO,IAAIJ,GAAJ,CAAQ,KAAKC,KAAb,EAAoB,KAAKC,OAAzB,EAAkC,KAAKC,GAAvC,EAA4CC,MAA5C,EAAoD,KAAKC,OAAzD,CAAP;AACD,CAFD;AAIA;;;;;;;;AAMAL,GAAG,CAACY,SAAJ,CAAcE,kBAAd,GAAmC,UAASC,OAAT,EAAkBC,UAAlB,EAA8B;AAC/D,MAAI,KAAKC,oBAAL,MAA+BF,OAAnC,EAA4C;AAC1C;AACA,QAAIG,GAAG,GAAG,IAAIrB,SAAJ,CAAc,KAAKI,KAAnB,EAA0B,KAAKE,GAA/B,CAAV;AACA,WAAOe,GAAG,CAACJ,kBAAJ,CAAuBC,OAAvB,EAAgCC,UAAhC,CAAP;AACD,GAJD,MAIO;AACL,WAAOhB,GAAG,CAACM,MAAJ,CAAWM,SAAX,CAAqBE,kBAArB,CAAwCP,IAAxC,CACH,IADG,EACGQ,OADH,EACYC,UADZ,CAAP;AAED;AACF,CATD;AAWA;;;;;;;AAKAhB,GAAG,CAACY,SAAJ,CAAcK,oBAAd,GAAqC,YAAW;AAC9C;AACA,MAAI,KAAKb,MAAT,EAAiB;AACf;AACA,QAAI,KAAKA,MAAL,YAAuBe,KAA3B,EAAkC;AAChC,aAAO,KAAKf,MAAL,CAAYgB,MAAZ,KAAuB,CAA9B;AACD,KAJc,CAMf;;;AACA,WAAOC,MAAM,CAAC,KAAKjB,MAAN,CAAN,CAAoBgB,MAApB,KAA+B,CAAtC;AACD;;AAED,SAAO,IAAP;AACD,CAbD;AAeA;;;;;;AAIApB,GAAG,CAACY,SAAJ,CAAcU,SAAd,GAA0B,UAASC,YAAT,EAAuB;AAC/C,MAAIC,IAAI,GAAG,IAAX;AACA,MAAIC,IAAI,GAAGF,YAAY,IAAIzB,IAA3B;AAEA0B,EAAAA,IAAI,CAACE,aAAL,CAAmB,IAAnB,EAAyB,UAASC,GAAT,EAAcC,MAAd,EAAsB;AAC7C,QAAI,CAACD,GAAL,EAAU;AACRH,MAAAA,IAAI,CAAChB,WAAL,GAAmBoB,MAAnB;AACAJ,MAAAA,IAAI,CAAChB,WAAL,CAAiBC,aAAjB,GAAiC,iBAAjC;AACAe,MAAAA,IAAI,CAACrB,GAAL,GAAWqB,IAAI,CAACK,MAAL,CAAY1B,GAAvB;AACAqB,MAAAA,IAAI,CAACvB,KAAL,GAAauB,IAAI,CAACK,MAAL,CAAYC,GAAzB;AACD;;AACDL,IAAAA,IAAI,CAACE,GAAD,EAAMC,MAAN,CAAJ;AACD,GARD;AASD,CAbD;AAgBA;;;;;;;;AAMA5B,GAAG,CAACY,SAAJ,CAAcc,aAAd,GAA8B,UAASK,QAAT,EAAmBR,YAAnB,EAAiC;AAC7D,MAAIE,IAAI,GAAGF,YAAY,IAAIzB,IAA3B;AAEA,SAAO,KAAKkC,aAAL,CAAmB,UAASL,GAAT,EAAc/B,MAAd,EAAsB;AAC9C,QAAI+B,GAAJ,EAAS;AACP,aAAOF,IAAI,CAACE,GAAD,CAAX;AACD,KAFD,MAEO;AACL,aAAO/B,MAAM,CAACqC,QAAP,CAAgB,UAAUN,GAAV,EAAeO,KAAf,EAAsB;AAC3C,eAAOT,IAAI,CAACE,GAAD,EAAM;AACfQ,UAAAA,YAAY,EAAED,KADC;AAEfE,UAAAA,UAAU,EAAE,QAFG;AAGf1B,UAAAA,WAAW,EAAEd,MAAM,CAACyC;AAHL,SAAN,CAAX;AAKD,OANM,CAAP;AAOD;AACF,GAZM,CAAP;AAaD,CAhBD;AAmBA;;;;;;;AAKArC,GAAG,CAACY,SAAJ,CAAc0B,QAAd,GAAyB,UAASC,IAAT,EAAehB,YAAf,EAA6B;AACpD,MAAIC,IAAI,GAAG,IAAX;AACA,MAAIC,IAAI,GAAGF,YAAY,IAAIzB,IAA3B;;AACA,MAAI,CAACyC,IAAL,EAAW;AACTd,IAAAA,IAAI,CAAC,IAAIe,KAAJ,CACH,0EADG,CAAD,CAAJ;AAEA;AACD;;AACD,MAAI,CAACD,IAAI,CAACE,YAAV,EAAwB;AACtBhB,IAAAA,IAAI,CAAC,IAAIe,KAAJ,CACH,gEADG,CAAD,CAAJ;AAEA;AACD;;AACD,MAAI,CAACD,IAAI,CAACG,WAAV,EAAuB;AACrBjB,IAAAA,IAAI,CAAC,IAAIe,KAAJ,CACH,+DADG,CAAD,CAAJ;AAEA;AACD,GAjBmD,CAkBpD;;;AACAhB,EAAAA,IAAI,CAACvB,KAAL,GAAasC,IAAI,CAACE,YAAlB;AACAjB,EAAAA,IAAI,CAACrB,GAAL,GAAWoC,IAAI,CAACG,WAAhB;AACAlB,EAAAA,IAAI,CAACmB,SAAL,GAAiBJ,IAAI,CAACK,UAAtB;AACAnB,EAAAA,IAAI;AACL,CAvBD;AAyBA;;;;;;;AAKAzB,GAAG,CAACY,SAAJ,CAAciC,UAAd,GAA2B,UAASC,MAAT,EAAiBvB,YAAjB,EAA+B;AACxD,MAAIC,IAAI,GAAG,IAAX;AACA,MAAIC,IAAI,GAAGF,YAAY,IAAIzB,IAA3B;;AAEA,MAAI,CAACgD,MAAL,EAAa;AACXC,IAAAA,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC1BvB,MAAAA,IAAI,CACF,IAAIe,KAAJ,CAAU,qEAAV,CADE,CAAJ;AAED,KAHD;AAIA;AACD;;AACD,MAAIS,CAAC,GAAG,EAAR;AACAH,EAAAA,MAAM,CAACI,WAAP,CAAmB,MAAnB;AACAJ,EAAAA,MAAM,CAACK,EAAP,CAAU,MAAV,EAAkB,UAAUC,KAAV,EAAiB;AACjCH,IAAAA,CAAC,IAAIG,KAAL;AACD,GAFD;AAGAN,EAAAA,MAAM,CAACK,EAAP,CAAU,KAAV,EAAiB,YAAY;AAC3B,QAAI;AACF,UAAIE,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWN,CAAX,CAAX;AACAzB,MAAAA,IAAI,CAACc,QAAL,CAAce,IAAd,EAAoB9B,YAApB;AACD,KAHD,CAGE,OAAOI,GAAP,EAAY;AACZF,MAAAA,IAAI,CAACE,GAAD,CAAJ;AACD;AACF,GAPD;AAQD,CAxBD;AA0BA;;;;;;;AAKA3B,GAAG,CAACY,SAAJ,CAAcoB,aAAd,GAA8B,UAASwB,QAAT,EAAmB;AAC/C,MAAI,KAAK3B,MAAT,EAAiB;AACf,WAAO2B,QAAQ,CAAC,IAAD,EAAO,KAAK3B,MAAZ,CAAf;AACD,GAFD,MAEO;AACL,SAAKA,MAAL,GAAc,KAAKjC,MAAL,CAAY;AACxBkC,MAAAA,GAAG,EAAE,KAAK7B,KADc;AAExBwD,MAAAA,GAAG,EAAE,KAAKpD,OAFc;AAGxBqD,MAAAA,KAAK,EAAE,KAAKtD,MAHY;AAIxBF,MAAAA,OAAO,EAAE,KAAKA,OAJU;AAKxBC,MAAAA,GAAG,EAAE,KAAKA;AALc,KAAZ,CAAd;AAOA,WAAOqD,QAAQ,CAAC,IAAD,EAAO,KAAK3B,MAAZ,CAAf;AACD;AACF,CAbD;AAeA;;;;;AAGA8B,MAAM,CAACC,OAAP,GAAiB5D,GAAjB","sourcesContent":["/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nvar Auth2Client = require('./oauth2client.js');\nvar gToken = require('gtoken');\nvar JWTAccess = require('./jwtaccess.js');\nvar noop = require('lodash.noop');\nvar util = require('util');\n\n\n/**\n * JWT service account credentials.\n *\n * Retrieve access token using gtoken.\n *\n * @param {string=} email service account email address.\n * @param {string=} keyFile path to private key file.\n * @param {string=} key value of key\n * @param {(string|array)=} scopes list of requested scopes or a single scope.\n * @param {string=} subject impersonated account's email address.\n * @constructor\n */\nfunction JWT(email, keyFile, key, scopes, subject) {\n  JWT.super_.call(this);\n  this.email = email;\n  this.keyFile = keyFile;\n  this.key = key;\n  this.scopes = scopes;\n  this.subject = subject;\n  this.gToken = gToken;\n\n  this.credentials = {\n    refresh_token: 'jwt-placeholder',\n    expiry_date: 1\n  };\n}\n\n/**\n * Inherit from Auth2Client.\n */\nutil.inherits(JWT, Auth2Client);\n\n/**\n * Creates a copy of the credential with the specified scopes.\n * @param {(string|array)=} scopes List of requested scopes or a single scope.\n * @return {object} The cloned instance.\n */\nJWT.prototype.createScoped = function(scopes) {\n  return new JWT(this.email, this.keyFile, this.key, scopes, this.subject);\n};\n\n/**\n * Obtains the metadata to be sent with the request.\n *\n * @param {string} opt_uri the URI being authorized.\n * @param {function} metadataCb\n */\nJWT.prototype.getRequestMetadata = function(opt_uri, metadataCb) {\n  if (this.createScopedRequired() && opt_uri) {\n    // no scopes have been set, but a uri has been provided.  Use JWTAccess credentials.\n    var alt = new JWTAccess(this.email, this.key);\n    return alt.getRequestMetadata(opt_uri, metadataCb);\n  } else {\n    return JWT.super_.prototype.getRequestMetadata.call(\n        this, opt_uri, metadataCb);\n  }\n};\n\n/**\n * Indicates whether the credential requires scopes to be created by calling createdScoped before\n * use.\n * @return {boolean} false if createScoped does not need to be called.\n */\nJWT.prototype.createScopedRequired = function() {\n  // If scopes is null, always return true.\n  if (this.scopes) {\n    // For arrays, check the array length.\n    if (this.scopes instanceof Array) {\n      return this.scopes.length === 0;\n    }\n\n    // For others, convert to a string and check the length.\n    return String(this.scopes).length === 0;\n  }\n\n  return true;\n};\n\n/**\n * Get the initial access token using gToken.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.authorize = function(opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  that.refreshToken_(null, function(err, result) {\n    if (!err) {\n      that.credentials = result;\n      that.credentials.refresh_token = 'jwt-placeholder';\n      that.key = that.gtoken.key;\n      that.email = that.gtoken.iss;\n    }\n    done(err, result);\n  });\n};\n\n\n/**\n * Refreshes the access token.\n * @param {object=} ignored_\n * @param {function=} opt_callback Optional callback.\n * @private\n */\nJWT.prototype.refreshToken_ = function(ignored_, opt_callback) {\n  var done = opt_callback || noop;\n\n  return this._createGToken(function(err, gToken) {\n    if (err) {\n      return done(err);\n    } else {\n      return gToken.getToken(function (err, token) {\n        return done(err, {\n          access_token: token,\n          token_type: 'Bearer',\n          expiry_date: gToken.expires_at\n        });\n      });\n    }\n  });\n};\n\n\n/**\n * Create a JWT credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.fromJSON = function(json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n  if (!json) {\n    done(new Error(\n      'Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n  if (!json.client_email) {\n    done(new Error(\n      'The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n  if (!json.private_key) {\n    done(new Error(\n      'The incoming JSON object does not contain a private_key field'));\n    return;\n  }\n  // Extract the relevant information from the json key file.\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n\n/**\n * Create a JWT credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\nJWT.prototype.fromStream = function(stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!stream) {\n    process.nextTick(function() {\n      done(\n        new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n\n/**\n * Creates the gToken instance if it has not been created already.\n * @param {function=} callback Callback.\n * @private\n */\nJWT.prototype._createGToken = function(callback) {\n  if (this.gtoken) {\n    return callback(null, this.gtoken);\n  } else {\n    this.gtoken = this.gToken({\n      iss: this.email,\n      sub: this.subject,\n      scope: this.scopes,\n      keyFile: this.keyFile,\n      key: this.key\n    });\n    return callback(null, this.gtoken);\n  }\n};\n\n/**\n * Export JWT.\n */\nmodule.exports = JWT;\n"]},"metadata":{},"sourceType":"script"}