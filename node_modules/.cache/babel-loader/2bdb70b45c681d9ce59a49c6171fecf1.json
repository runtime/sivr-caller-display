{"ast":null,"code":"/*\n * webhook.js: Transport for logging to remote http endpoints ( POST / RECEIVE webhooks )\n *\n * (C) 2011 Marak Squires\n * MIT LICENCE\n *\n */\nvar events = require('events'),\n    http = require('http'),\n    https = require('https'),\n    util = require('util'),\n    cycle = require('cycle'),\n    common = require('../common'),\n    Transport = require('./transport').Transport; //\n// ### function WebHook (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Console transport object responsible\n// for making arbitrary HTTP requests whenever log messages and metadata\n// are received.\n//\n\n\nvar Webhook = exports.Webhook = function (options) {\n  Transport.call(this, options);\n  this.name = 'webhook';\n  this.host = options.host || 'localhost';\n  this.port = options.port || 8080;\n  this.method = options.method || 'POST';\n  this.path = options.path || '/winston-log';\n\n  if (options.auth) {\n    this.auth = {};\n    this.auth.username = options.auth.username || '';\n    this.auth.password = options.auth.password || '';\n  }\n\n  if (options.ssl) {\n    this.port = options.port || 443;\n    this.ssl = {\n      key: options.ssl.key || null,\n      cert: options.ssl.cert || null,\n      ca: options.ssl.ca\n    };\n  }\n}; //\n// Inherit from `winston.Transport`.\n//\n\n\nutil.inherits(Webhook, Transport); //\n// Expose the name of this Transport on the prototype\n//\n\nWebhook.prototype.name = 'webhook'; //\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\n\nWebhook.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      meta = cycle.decycle(meta),\n      message = common.clone(meta),\n      options,\n      req; // Prepare options for outgoing HTTP request\n\n  options = {\n    host: this.host,\n    port: this.port,\n    path: this.path,\n    method: this.method,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n\n  if (this.ssl) {\n    options.ca = this.ssl.ca;\n    options.key = this.ssl.key;\n    options.cert = this.ssl.cert; // Required for the test fixture SSL certificate to be considered valid.\n\n    options.rejectUnauthorized = false;\n  }\n\n  if (this.auth) {\n    // Encode `Authorization` header used by Basic Auth\n    options.headers['Authorization'] = 'Basic ' + new Buffer(this.auth.username + ':' + this.auth.password, 'utf8').toString('base64');\n  } // Perform HTTP logging request\n\n\n  req = (self.ssl ? https : http).request(options, function (res) {\n    // TODO: emit 'logged' correctly,\n    // keep track of pending logs.\n    res.on('data', function (data) {// Do nothing. We need to read the response, or we run into maxSockets\n      // after 5 requests.\n    });\n    self.emit('logged');\n    if (callback) callback(null, true);\n    callback = null;\n  });\n  req.on('error', function (err) {\n    //\n    // Propagate the `error` back up to the `Logger` that this\n    // instance belongs to.\n    //\n    self.emit('error', err);\n    if (callback) callback(err, false);\n    callback = null;\n  }); //\n  // Write logging event to the outgoing request body\n  //\n  // jsonMessage is currently conforming to JSON-RPC v1.0,\n  // but without the unique id since there is no anticipated response\n  // see: http://en.wikipedia.org/wiki/JSON-RPC\n  //\n\n  var params = common.clone(meta) || {};\n  params.timestamp = new Date();\n  params.message = msg;\n  params.level = level;\n  req.write(JSON.stringify({\n    method: 'log',\n    params: params\n  }));\n  req.end();\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/winston/lib/winston/transports/webhook.js"],"names":["events","require","http","https","util","cycle","common","Transport","Webhook","exports","options","call","name","host","port","method","path","auth","username","password","ssl","key","cert","ca","inherits","prototype","log","level","msg","meta","callback","silent","self","decycle","message","clone","req","headers","rejectUnauthorized","Buffer","toString","request","res","on","data","emit","err","params","timestamp","Date","write","JSON","stringify","end"],"mappings":"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","sourcesContent":["/*\n * webhook.js: Transport for logging to remote http endpoints ( POST / RECEIVE webhooks )\n *\n * (C) 2011 Marak Squires\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    http = require('http'),\n    https = require('https'),\n    util = require('util'),\n    cycle = require('cycle'),\n    common = require('../common'),\n    Transport = require('./transport').Transport;\n\n//\n// ### function WebHook (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Console transport object responsible\n// for making arbitrary HTTP requests whenever log messages and metadata\n// are received.\n//\nvar Webhook = exports.Webhook = function (options) {\n  Transport.call(this, options);\n\n  this.name   = 'webhook';\n  this.host   = options.host   || 'localhost';\n  this.port   = options.port   || 8080;\n  this.method = options.method || 'POST';\n  this.path   = options.path   || '/winston-log';\n\n  if (options.auth) {\n    this.auth = {};\n    this.auth.username = options.auth.username || '';\n    this.auth.password = options.auth.password || '';\n  }\n\n  if (options.ssl) {\n    this.port     = options.port || 443;\n    this.ssl      = {\n      key:  options.ssl.key  || null,\n      cert: options.ssl.cert || null,\n      ca:   options.ssl.ca\n    };\n  }\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(Webhook, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nWebhook.prototype.name = 'webhook';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nWebhook.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      meta = cycle.decycle(meta),\n      message = common.clone(meta),\n      options,\n      req;\n\n  // Prepare options for outgoing HTTP request\n  options = {\n    host: this.host,\n    port: this.port,\n    path: this.path,\n    method: this.method,\n    headers: { 'Content-Type': 'application/json' }\n  };\n\n  if (this.ssl) {\n    options.ca = this.ssl.ca;\n    options.key = this.ssl.key;\n    options.cert = this.ssl.cert;\n\n    // Required for the test fixture SSL certificate to be considered valid.\n    options.rejectUnauthorized = false;\n  }\n\n  if (this.auth) {\n    // Encode `Authorization` header used by Basic Auth\n    options.headers['Authorization'] = 'Basic ' + new Buffer(\n      this.auth.username + ':' + this.auth.password, 'utf8'\n    ).toString('base64');\n  }\n\n  // Perform HTTP logging request\n  req = (self.ssl ? https : http).request(options, function (res) {\n    // TODO: emit 'logged' correctly,\n    // keep track of pending logs.\n    res.on('data', function(data) {\n      // Do nothing. We need to read the response, or we run into maxSockets\n      // after 5 requests.\n    });\n\n    self.emit('logged');\n    if (callback) callback(null, true);\n    callback = null;\n  });\n\n  req.on('error', function (err) {\n    //\n    // Propagate the `error` back up to the `Logger` that this\n    // instance belongs to.\n    //\n    self.emit('error', err);\n    if (callback) callback(err, false);\n    callback = null;\n  });\n\n  //\n  // Write logging event to the outgoing request body\n  //\n  // jsonMessage is currently conforming to JSON-RPC v1.0,\n  // but without the unique id since there is no anticipated response\n  // see: http://en.wikipedia.org/wiki/JSON-RPC\n  //\n\n  var params = common.clone(meta) || {};\n  params.timestamp = new Date();\n  params.message = msg;\n  params.level = level;\n\n  req.write(JSON.stringify({\n    method: 'log',\n    params: params\n  }));\n\n  req.end();\n};\n"]},"metadata":{},"sourceType":"script"}