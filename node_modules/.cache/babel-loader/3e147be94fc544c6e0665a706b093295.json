{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst extend = require(\"extend\");\n\nconst message_queues_1 = require(\"./message-queues\");\n\nexports.BATCH_LIMITS = {\n  maxBytes: Math.pow(1024, 2) * 9,\n  maxMessages: 1000\n};\n/**\n * A Publisher object allows you to publish messages to a specific topic.\n *\n * @private\n * @class\n *\n * @see [Topics: publish API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/publish}\n *\n * @param {Topic} topic The topic associated with this publisher.\n * @param {PublishOptions} [options] Configuration object.\n */\n\nclass Publisher {\n  constructor(topic, options) {\n    if (topic.Promise) {\n      this.Promise = topic.Promise;\n    }\n\n    this.setOptions(options);\n    this.topic = topic;\n    this.queue = new message_queues_1.Queue(this);\n    this.orderedQueues = new Map();\n  }\n  /**\n   * Publish the provided message.\n   *\n   * @deprecated use {@link Publisher#publishMessage} instead.\n   *\n   * @private\n   * @see Publisher#publishMessage\n   *\n   * @param {buffer} data The message data. This must come in the form of a\n   *     Buffer object.\n   * @param {object.<string, string>} [attributes] Attributes for this message.\n   * @param {PublishCallback} [callback] Callback function.\n   * @returns {Promise<PublishResponse>}\n   */\n\n\n  publish(data, attrsOrCb, callback) {\n    const attributes = typeof attrsOrCb === 'object' ? attrsOrCb : {};\n    callback = typeof attrsOrCb === 'function' ? attrsOrCb : callback;\n    return this.publishMessage({\n      data,\n      attributes\n    }, callback);\n  }\n  /**\n   * Publish the provided message.\n   *\n   * @private\n   *\n   * @throws {TypeError} If data is not a Buffer object.\n   * @throws {TypeError} If any value in `attributes` object is not a string.\n   *\n   * @param {PubsubMessage} [message] Options for this message.\n   * @param {PublishCallback} [callback] Callback function.\n   */\n\n\n  publishMessage(message, callback) {\n    const data = message.data,\n          _message$attributes = message.attributes,\n          attributes = _message$attributes === void 0 ? {} : _message$attributes;\n\n    if (!(data instanceof Buffer)) {\n      throw new TypeError('Data must be in the form of a Buffer.');\n    }\n\n    for (const key of Object.keys(attributes)) {\n      const value = attributes[key];\n\n      if (typeof value !== 'string') {\n        throw new TypeError(`All attributes must be in the form of a string.\n\\nInvalid value of type \"${typeof value}\" provided for \"${key}\".`);\n      }\n    }\n\n    if (!message.orderingKey) {\n      this.queue.add(message, callback);\n      return;\n    }\n\n    const key = message.orderingKey;\n\n    if (!this.orderedQueues.has(key)) {\n      const queue = new message_queues_1.OrderedQueue(this, key);\n      this.orderedQueues.set(key, queue);\n      queue.once('drain', () => this.orderedQueues.delete(key));\n    }\n\n    const queue = this.orderedQueues.get(key);\n    queue.add(message, callback);\n  }\n  /**\n   * Indicates to the publisher that it is safe to continue publishing for the\n   * supplied ordering key.\n   *\n   * @private\n   *\n   * @param {string} key The ordering key to continue publishing for.\n   */\n\n\n  resumePublishing(key) {\n    const queue = this.orderedQueues.get(key);\n\n    if (queue) {\n      queue.resumePublishing();\n    }\n  }\n  /**\n   * Sets the Publisher options.\n   *\n   * @private\n   *\n   * @param {PublishOptions} options The publisher options.\n   */\n\n\n  setOptions(options = {}) {\n    const defaults = {\n      batching: {\n        maxBytes: Math.pow(1024, 2) * 5,\n        maxMessages: 1000,\n        maxMilliseconds: 100\n      },\n      messageOrdering: false,\n      gaxOpts: {\n        isBundling: false\n      }\n    };\n\n    const _extend = extend(true, defaults, options),\n          batching = _extend.batching,\n          gaxOpts = _extend.gaxOpts,\n          messageOrdering = _extend.messageOrdering;\n\n    this.settings = {\n      batching: {\n        maxBytes: Math.min(batching.maxBytes, exports.BATCH_LIMITS.maxBytes),\n        maxMessages: Math.min(batching.maxMessages, exports.BATCH_LIMITS.maxMessages),\n        maxMilliseconds: batching.maxMilliseconds\n      },\n      gaxOpts,\n      messageOrdering\n    };\n  }\n\n}\n\nexports.Publisher = Publisher;\npromisify_1.promisifyAll(Publisher, {\n  singular: true,\n  exclude: ['publish', 'setOptions']\n});","map":{"version":3,"sources":["../../../src/publisher/index.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA,MAAA,WAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAIA,MAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAmBa,OAAA,CAAA,YAAA,GAAoC;AAC/C,EAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,CAAf,IAAoB,CADiB;AAE/C,EAAA,WAAW,EAAE;AAFkC,CAApC;AAKb;;;;;;;;;;;;AAWA,MAAa,SAAb,CAAsB;AAOpB,EAAA,WAAA,CAAY,KAAZ,EAA0B,OAA1B,EAAkD;AAChD,QAAI,KAAK,CAAC,OAAV,EAAmB;AACjB,WAAK,OAAL,GAAe,KAAK,CAAC,OAArB;AACD;;AAED,SAAK,UAAL,CAAgB,OAAhB;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,KAAL,GAAa,IAAI,gBAAA,CAAA,KAAJ,CAAU,IAAV,CAAb;AACA,SAAK,aAAL,GAAqB,IAAI,GAAJ,EAArB;AACD;AAQD;;;;;;;;;;;;;;;;AAcA,EAAA,OAAO,CACL,IADK,EAEL,SAFK,EAGL,QAHK,EAGqB;AAE1B,UAAM,UAAU,GAAG,OAAO,SAAP,KAAqB,QAArB,GAAgC,SAAhC,GAA4C,EAA/D;AACA,IAAA,QAAQ,GAAG,OAAO,SAAP,KAAqB,UAArB,GAAkC,SAAlC,GAA8C,QAAzD;AACA,WAAO,KAAK,cAAL,CAAoB;AAAC,MAAA,IAAD;AAAO,MAAA;AAAP,KAApB,EAAwC,QAAxC,CAAP;AACD;AACD;;;;;;;;;;;;;AAWA,EAAA,cAAc,CAAC,OAAD,EAAyB,QAAzB,EAAkD;AAAA,UACvD,IADuD,GAC9B,OAD8B,CACvD,IADuD;AAAA,gCAC9B,OAD8B,CACjD,UADiD;AAAA,UACjD,UADiD,oCACpC,EADoC;;AAG9D,QAAI,EAAE,IAAI,YAAY,MAAlB,CAAJ,EAA+B;AAC7B,YAAM,IAAI,SAAJ,CAAc,uCAAd,CAAN;AACD;;AAED,SAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,UAAZ,CAAlB,EAA4C;AAC1C,YAAM,KAAK,GAAG,UAAW,CAAC,GAAD,CAAzB;;AACA,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,cAAM,IAAI,SAAJ,CAAc;2BACD,OAAO,KAAK,mBAAmB,GAAG,IAD/C,CAAN;AAED;AACF;;AAED,QAAI,CAAC,OAAO,CAAC,WAAb,EAA0B;AACxB,WAAK,KAAL,CAAW,GAAX,CAAe,OAAf,EAAwB,QAAxB;AACA;AACD;;AAED,UAAM,GAAG,GAAG,OAAO,CAAC,WAApB;;AAEA,QAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,GAAvB,CAAL,EAAkC;AAChC,YAAM,KAAK,GAAG,IAAI,gBAAA,CAAA,YAAJ,CAAiB,IAAjB,EAAuB,GAAvB,CAAd;AACA,WAAK,aAAL,CAAmB,GAAnB,CAAuB,GAAvB,EAA4B,KAA5B;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,OAAX,EAAoB,MAAM,KAAK,aAAL,CAAmB,MAAnB,CAA0B,GAA1B,CAA1B;AACD;;AAED,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,GAAnB,CAAuB,GAAvB,CAAd;AACA,IAAA,KAAK,CAAC,GAAN,CAAU,OAAV,EAAmB,QAAnB;AACD;AACD;;;;;;;;;;AAQA,EAAA,gBAAgB,CAAC,GAAD,EAAY;AAC1B,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,GAAnB,CAAuB,GAAvB,CAAd;;AAEA,QAAI,KAAJ,EAAW;AACT,MAAA,KAAK,CAAC,gBAAN;AACD;AACF;AACD;;;;;;;;;AAOA,EAAA,UAAU,CAAC,OAAA,GAAU,EAAX,EAA+B;AACvC,UAAM,QAAQ,GAAG;AACf,MAAA,QAAQ,EAAE;AACR,QAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,CAAf,IAAoB,CADtB;AAER,QAAA,WAAW,EAAE,IAFL;AAGR,QAAA,eAAe,EAAE;AAHT,OADK;AAMf,MAAA,eAAe,EAAE,KANF;AAOf,MAAA,OAAO,EAAE;AACP,QAAA,UAAU,EAAE;AADL;AAPM,KAAjB;;AADuC,oBAaM,MAAM,CACjD,IADiD,EAEjD,QAFiD,EAGjD,OAHiD,CAbZ;AAAA,UAahC,QAbgC,WAahC,QAbgC;AAAA,UAatB,OAbsB,WAatB,OAbsB;AAAA,UAab,eAba,WAab,eAba;;AAmBvC,SAAK,QAAL,GAAgB;AACd,MAAA,QAAQ,EAAE;AACR,QAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,QAAlB,EAA4B,OAAA,CAAA,YAAA,CAAa,QAAzC,CADF;AAER,QAAA,WAAW,EAAE,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,WAAlB,EAA+B,OAAA,CAAA,YAAA,CAAa,WAA5C,CAFL;AAGR,QAAA,eAAe,EAAE,QAAQ,CAAC;AAHlB,OADI;AAMd,MAAA,OANc;AAOd,MAAA;AAPc,KAAhB;AASD;;AA3ImB;;AAAtB,OAAA,CAAA,SAAA,GAAA,SAAA;AA8IA,WAAA,CAAA,YAAA,CAAa,SAAb,EAAwB;AACtB,EAAA,QAAQ,EAAE,IADY;AAEtB,EAAA,OAAO,EAAE,CAAC,SAAD,EAAY,YAAZ;AAFa,CAAxB","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst extend = require(\"extend\");\nconst message_queues_1 = require(\"./message-queues\");\nexports.BATCH_LIMITS = {\n    maxBytes: Math.pow(1024, 2) * 9,\n    maxMessages: 1000,\n};\n/**\n * A Publisher object allows you to publish messages to a specific topic.\n *\n * @private\n * @class\n *\n * @see [Topics: publish API Documentation]{@link https://cloud.google.com/pubsub/docs/reference/rest/v1/projects.topics/publish}\n *\n * @param {Topic} topic The topic associated with this publisher.\n * @param {PublishOptions} [options] Configuration object.\n */\nclass Publisher {\n    constructor(topic, options) {\n        if (topic.Promise) {\n            this.Promise = topic.Promise;\n        }\n        this.setOptions(options);\n        this.topic = topic;\n        this.queue = new message_queues_1.Queue(this);\n        this.orderedQueues = new Map();\n    }\n    /**\n     * Publish the provided message.\n     *\n     * @deprecated use {@link Publisher#publishMessage} instead.\n     *\n     * @private\n     * @see Publisher#publishMessage\n     *\n     * @param {buffer} data The message data. This must come in the form of a\n     *     Buffer object.\n     * @param {object.<string, string>} [attributes] Attributes for this message.\n     * @param {PublishCallback} [callback] Callback function.\n     * @returns {Promise<PublishResponse>}\n     */\n    publish(data, attrsOrCb, callback) {\n        const attributes = typeof attrsOrCb === 'object' ? attrsOrCb : {};\n        callback = typeof attrsOrCb === 'function' ? attrsOrCb : callback;\n        return this.publishMessage({ data, attributes }, callback);\n    }\n    /**\n     * Publish the provided message.\n     *\n     * @private\n     *\n     * @throws {TypeError} If data is not a Buffer object.\n     * @throws {TypeError} If any value in `attributes` object is not a string.\n     *\n     * @param {PubsubMessage} [message] Options for this message.\n     * @param {PublishCallback} [callback] Callback function.\n     */\n    publishMessage(message, callback) {\n        const { data, attributes = {} } = message;\n        if (!(data instanceof Buffer)) {\n            throw new TypeError('Data must be in the form of a Buffer.');\n        }\n        for (const key of Object.keys(attributes)) {\n            const value = attributes[key];\n            if (typeof value !== 'string') {\n                throw new TypeError(`All attributes must be in the form of a string.\n\\nInvalid value of type \"${typeof value}\" provided for \"${key}\".`);\n            }\n        }\n        if (!message.orderingKey) {\n            this.queue.add(message, callback);\n            return;\n        }\n        const key = message.orderingKey;\n        if (!this.orderedQueues.has(key)) {\n            const queue = new message_queues_1.OrderedQueue(this, key);\n            this.orderedQueues.set(key, queue);\n            queue.once('drain', () => this.orderedQueues.delete(key));\n        }\n        const queue = this.orderedQueues.get(key);\n        queue.add(message, callback);\n    }\n    /**\n     * Indicates to the publisher that it is safe to continue publishing for the\n     * supplied ordering key.\n     *\n     * @private\n     *\n     * @param {string} key The ordering key to continue publishing for.\n     */\n    resumePublishing(key) {\n        const queue = this.orderedQueues.get(key);\n        if (queue) {\n            queue.resumePublishing();\n        }\n    }\n    /**\n     * Sets the Publisher options.\n     *\n     * @private\n     *\n     * @param {PublishOptions} options The publisher options.\n     */\n    setOptions(options = {}) {\n        const defaults = {\n            batching: {\n                maxBytes: Math.pow(1024, 2) * 5,\n                maxMessages: 1000,\n                maxMilliseconds: 100,\n            },\n            messageOrdering: false,\n            gaxOpts: {\n                isBundling: false,\n            },\n        };\n        const { batching, gaxOpts, messageOrdering } = extend(true, defaults, options);\n        this.settings = {\n            batching: {\n                maxBytes: Math.min(batching.maxBytes, exports.BATCH_LIMITS.maxBytes),\n                maxMessages: Math.min(batching.maxMessages, exports.BATCH_LIMITS.maxMessages),\n                maxMilliseconds: batching.maxMilliseconds,\n            },\n            gaxOpts,\n            messageOrdering,\n        };\n    }\n}\nexports.Publisher = Publisher;\npromisify_1.promisifyAll(Publisher, {\n    singular: true,\n    exclude: ['publish', 'setOptions'],\n});\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}