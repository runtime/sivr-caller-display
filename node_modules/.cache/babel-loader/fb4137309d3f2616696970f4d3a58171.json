{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst clc = require(\"cli-color\");\n\nconst api = require(\"../api\");\n\nconst logger = require(\"../logger\");\n\nconst utils = require(\"../utils\");\n\nconst validator = require(\"./validator\");\n\nconst API = require(\"./indexes-api\");\n\nconst sort = require(\"./indexes-sort\");\n\nconst util = require(\"./util\");\n\nclass FirestoreIndexes {\n  deploy(project, indexes, fieldOverrides) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const spec = this.upgradeOldSpec({\n        indexes,\n        fieldOverrides\n      });\n      this.validateSpec(spec);\n      const indexesToDeploy = spec.indexes;\n      const fieldOverridesToDeploy = spec.fieldOverrides;\n      const existingIndexes = yield this.listIndexes(project);\n      const existingFieldOverrides = yield this.listFieldOverrides(project);\n\n      if (existingIndexes.length > indexesToDeploy.length) {\n        utils.logBullet(clc.bold.cyan(\"firestore:\") + \" there are some indexes defined in your project that are not present in your \" + \"firestore indexes file. Run firebase firestore:indexes and save the result to correct the discrepancy.\");\n      }\n\n      for (const index of indexesToDeploy) {\n        const exists = existingIndexes.some(x => this.indexMatchesSpec(x, index));\n\n        if (exists) {\n          logger.debug(`Skipping existing index: ${JSON.stringify(index)}`);\n        } else {\n          logger.debug(`Creating new index: ${JSON.stringify(index)}`);\n          yield this.createIndex(project, index);\n        }\n      }\n\n      if (existingFieldOverrides.length > fieldOverridesToDeploy.length) {\n        utils.logBullet(clc.bold.cyan(\"firestore:\") + \" there are some field overrides defined in your project that are not present in your \" + \"firestore indexes file. Run firebase firestore:indexes and save the result to correct the discrepancy.\");\n      }\n\n      for (const field of fieldOverridesToDeploy) {\n        const exists = existingFieldOverrides.some(x => this.fieldMatchesSpec(x, field));\n\n        if (exists) {\n          logger.debug(`Skipping existing field override: ${JSON.stringify(field)}`);\n        } else {\n          logger.debug(`Updating field override: ${JSON.stringify(field)}`);\n          yield this.patchField(project, field);\n        }\n      }\n    });\n  }\n\n  listIndexes(project) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = `projects/${project}/databases/(default)/collectionGroups/-/indexes`;\n      const res = yield api.request(\"GET\", `/v1beta2/${url}`, {\n        auth: true,\n        origin: api.firestoreOrigin\n      });\n      const indexes = res.body.indexes;\n\n      if (!indexes) {\n        return [];\n      }\n\n      return indexes.map(index => {\n        const fields = index.fields.filter(field => {\n          return field.fieldPath !== \"__name__\";\n        });\n        return {\n          name: index.name,\n          state: index.state,\n          queryScope: index.queryScope,\n          fields\n        };\n      });\n    });\n  }\n\n  listFieldOverrides(project) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const parent = `projects/${project}/databases/(default)/collectionGroups/-`;\n      const url = `${parent}/fields?filter=indexConfig.usesAncestorConfig=false`;\n      const res = yield api.request(\"GET\", `/v1beta2/${url}`, {\n        auth: true,\n        origin: api.firestoreOrigin\n      });\n      const fields = res.body.fields;\n\n      if (!fields) {\n        return [];\n      }\n\n      return fields.filter(field => {\n        return field.name.indexOf(\"__default__\") < 0;\n      });\n    });\n  }\n\n  makeIndexSpec(indexes, fields) {\n    const indexesJson = indexes.map(index => {\n      return {\n        collectionGroup: util.parseIndexName(index.name).collectionGroupId,\n        queryScope: index.queryScope,\n        fields: index.fields\n      };\n    });\n\n    if (!fields) {\n      logger.debug(\"No field overrides specified, using [].\");\n      fields = [];\n    }\n\n    const fieldsJson = fields.map(field => {\n      const parsedName = util.parseFieldName(field.name);\n      const fieldIndexes = field.indexConfig.indexes || [];\n      return {\n        collectionGroup: parsedName.collectionGroupId,\n        fieldPath: parsedName.fieldPath,\n        indexes: fieldIndexes.map(index => {\n          const firstField = index.fields[0];\n          return {\n            order: firstField.order,\n            arrayConfig: firstField.arrayConfig,\n            queryScope: index.queryScope\n          };\n        })\n      };\n    });\n    const sortedIndexes = indexesJson.sort(sort.compareSpecIndex);\n    const sortedFields = fieldsJson.sort(sort.compareFieldOverride);\n    return {\n      indexes: sortedIndexes,\n      fieldOverrides: sortedFields\n    };\n  }\n\n  prettyPrintIndexes(indexes) {\n    if (indexes.length === 0) {\n      logger.info(\"None\");\n      return;\n    }\n\n    const sortedIndexes = indexes.sort(sort.compareApiIndex);\n    sortedIndexes.forEach(index => {\n      logger.info(this.prettyIndexString(index));\n    });\n  }\n\n  printFieldOverrides(fields) {\n    if (fields.length === 0) {\n      logger.info(\"None\");\n      return;\n    }\n\n    const sortedFields = fields.sort(sort.compareApiField);\n    sortedFields.forEach(field => {\n      logger.info(this.prettyFieldString(field));\n    });\n  }\n\n  validateSpec(spec) {\n    validator.assertHas(spec, \"indexes\");\n    spec.indexes.forEach(index => {\n      this.validateIndex(index);\n    });\n\n    if (spec.fieldOverrides) {\n      spec.fieldOverrides.forEach(field => {\n        this.validateField(field);\n      });\n    }\n  }\n\n  validateIndex(index) {\n    validator.assertHas(index, \"collectionGroup\");\n    validator.assertHas(index, \"queryScope\");\n    validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n    validator.assertHas(index, \"fields\");\n    index.fields.forEach(field => {\n      validator.assertHas(field, \"fieldPath\");\n      validator.assertHasOneOf(field, [\"order\", \"arrayConfig\"]);\n\n      if (field.order) {\n        validator.assertEnum(field, \"order\", Object.keys(API.Order));\n      }\n\n      if (field.arrayConfig) {\n        validator.assertEnum(field, \"arrayConfig\", Object.keys(API.ArrayConfig));\n      }\n    });\n  }\n\n  validateField(field) {\n    validator.assertHas(field, \"collectionGroup\");\n    validator.assertHas(field, \"fieldPath\");\n    validator.assertHas(field, \"indexes\");\n    field.indexes.forEach(index => {\n      validator.assertHasOneOf(index, [\"arrayConfig\", \"order\"]);\n\n      if (index.arrayConfig) {\n        validator.assertEnum(index, \"arrayConfig\", Object.keys(API.ArrayConfig));\n      }\n\n      if (index.order) {\n        validator.assertEnum(index, \"order\", Object.keys(API.Order));\n      }\n\n      if (index.queryScope) {\n        validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n      }\n    });\n  }\n\n  patchField(project, spec) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const url = `projects/${project}/databases/(default)/collectionGroups/${spec.collectionGroup}/fields/${spec.fieldPath}`;\n      const indexes = spec.indexes.map(index => {\n        return {\n          queryScope: index.queryScope,\n          fields: [{\n            fieldPath: spec.fieldPath,\n            arrayConfig: index.arrayConfig,\n            order: index.order\n          }]\n        };\n      });\n      const data = {\n        indexConfig: {\n          indexes\n        }\n      };\n      yield api.request(\"PATCH\", `/v1beta2/${url}`, {\n        auth: true,\n        origin: api.firestoreOrigin,\n        data\n      });\n    });\n  }\n\n  createIndex(project, index) {\n    const url = `projects/${project}/databases/(default)/collectionGroups/${index.collectionGroup}/indexes`;\n    return api.request(\"POST\", \"/v1beta2/\" + url, {\n      auth: true,\n      data: {\n        fields: index.fields,\n        queryScope: index.queryScope\n      },\n      origin: api.firestoreOrigin\n    });\n  }\n\n  indexMatchesSpec(index, spec) {\n    const collection = util.parseIndexName(index.name).collectionGroupId;\n\n    if (collection !== spec.collectionGroup) {\n      return false;\n    }\n\n    if (index.queryScope !== spec.queryScope) {\n      return false;\n    }\n\n    if (index.fields.length !== spec.fields.length) {\n      return false;\n    }\n\n    let i = 0;\n\n    while (i < index.fields.length) {\n      const iField = index.fields[i];\n      const sField = spec.fields[i];\n\n      if (iField.fieldPath !== sField.fieldPath) {\n        return false;\n      }\n\n      if (iField.order !== sField.order) {\n        return false;\n      }\n\n      if (iField.arrayConfig !== sField.arrayConfig) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  }\n\n  fieldMatchesSpec(field, spec) {\n    const parsedName = util.parseFieldName(field.name);\n\n    if (parsedName.collectionGroupId !== spec.collectionGroup) {\n      return false;\n    }\n\n    if (parsedName.fieldPath !== spec.fieldPath) {\n      return false;\n    }\n\n    const fieldIndexes = field.indexConfig.indexes || [];\n\n    if (fieldIndexes.length !== spec.indexes.length) {\n      return false;\n    }\n\n    const fieldModes = fieldIndexes.map(index => {\n      const firstField = index.fields[0];\n      return firstField.order || firstField.arrayConfig;\n    });\n    const specModes = spec.indexes.map(index => {\n      return index.order || index.arrayConfig;\n    });\n\n    for (const mode of fieldModes) {\n      if (specModes.indexOf(mode) < 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  upgradeOldSpec(spec) {\n    const result = {\n      indexes: [],\n      fieldOverrides: spec.fieldOverrides || []\n    };\n\n    if (!(spec.indexes && spec.indexes.length > 0)) {\n      return result;\n    }\n\n    if (spec.indexes[0].collectionId) {\n      utils.logBullet(clc.bold.cyan(\"firestore:\") + \" your indexes indexes are specified in the v1beta1 API format. \" + \"Please upgrade to the new index API format by running \" + clc.bold(\"firebase firestore:indexes\") + \" again and saving the result.\");\n    }\n\n    result.indexes = spec.indexes.map(index => {\n      const i = {\n        collectionGroup: index.collectionGroup || index.collectionId,\n        queryScope: index.queryScope || API.QueryScope.COLLECTION,\n        fields: []\n      };\n\n      if (index.fields) {\n        i.fields = index.fields.map(field => {\n          const f = {\n            fieldPath: field.fieldPath\n          };\n\n          if (field.order) {\n            f.order = field.order;\n          } else if (field.arrayConfig) {\n            f.arrayConfig = field.arrayConfig;\n          } else if (field.mode === API.Mode.ARRAY_CONTAINS) {\n            f.arrayConfig = API.ArrayConfig.CONTAINS;\n          } else {\n            f.order = field.mode;\n          }\n\n          return f;\n        });\n      }\n\n      return i;\n    });\n    return result;\n  }\n\n  prettyIndexString(index) {\n    let result = \"\";\n\n    if (index.state) {\n      const stateMsg = `[${index.state}] `;\n\n      if (index.state === API.State.READY) {\n        result += clc.green(stateMsg);\n      } else if (index.state === API.State.CREATING) {\n        result += clc.yellow(stateMsg);\n      } else {\n        result += clc.red(stateMsg);\n      }\n    }\n\n    const nameInfo = util.parseIndexName(index.name);\n    result += clc.cyan(`(${nameInfo.collectionGroupId})`);\n    result += \" -- \";\n    index.fields.forEach(field => {\n      if (field.fieldPath === \"__name__\") {\n        return;\n      }\n\n      const orderOrArrayConfig = field.order ? field.order : field.arrayConfig;\n      result += `(${field.fieldPath},${orderOrArrayConfig}) `;\n    });\n    return result;\n  }\n\n  prettyFieldString(field) {\n    let result = \"\";\n    const parsedName = util.parseFieldName(field.name);\n    result += \"[\" + clc.cyan(parsedName.collectionGroupId) + \".\" + clc.yellow(parsedName.fieldPath) + \"] --\";\n    const fieldIndexes = field.indexConfig.indexes || [];\n\n    if (fieldIndexes.length > 0) {\n      fieldIndexes.forEach(index => {\n        const firstField = index.fields[0];\n        const mode = firstField.order || firstField.arrayConfig;\n        result += ` (${mode})`;\n      });\n    } else {\n      result += \" (no indexes)\";\n    }\n\n    return result;\n  }\n\n}\n\nexports.FirestoreIndexes = FirestoreIndexes;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/firestore/indexes.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","clc","require","api","logger","utils","validator","API","sort","util","FirestoreIndexes","deploy","project","indexes","fieldOverrides","spec","upgradeOldSpec","validateSpec","indexesToDeploy","fieldOverridesToDeploy","existingIndexes","listIndexes","existingFieldOverrides","listFieldOverrides","length","logBullet","bold","cyan","index","exists","some","x","indexMatchesSpec","debug","JSON","stringify","createIndex","field","fieldMatchesSpec","patchField","url","res","request","auth","origin","firestoreOrigin","body","map","fields","filter","fieldPath","name","state","queryScope","parent","indexOf","makeIndexSpec","indexesJson","collectionGroup","parseIndexName","collectionGroupId","fieldsJson","parsedName","parseFieldName","fieldIndexes","indexConfig","firstField","order","arrayConfig","sortedIndexes","compareSpecIndex","sortedFields","compareFieldOverride","prettyPrintIndexes","info","compareApiIndex","forEach","prettyIndexString","printFieldOverrides","compareApiField","prettyFieldString","assertHas","validateIndex","validateField","assertEnum","keys","QueryScope","assertHasOneOf","Order","ArrayConfig","data","collection","i","iField","sField","fieldModes","specModes","mode","collectionId","COLLECTION","f","Mode","ARRAY_CONTAINS","CONTAINS","stateMsg","State","READY","green","CREATING","yellow","red","nameInfo","orderOrArrayConfig"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst clc = require(\"cli-color\");\nconst api = require(\"../api\");\nconst logger = require(\"../logger\");\nconst utils = require(\"../utils\");\nconst validator = require(\"./validator\");\nconst API = require(\"./indexes-api\");\nconst sort = require(\"./indexes-sort\");\nconst util = require(\"./util\");\nclass FirestoreIndexes {\n    deploy(project, indexes, fieldOverrides) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const spec = this.upgradeOldSpec({\n                indexes,\n                fieldOverrides,\n            });\n            this.validateSpec(spec);\n            const indexesToDeploy = spec.indexes;\n            const fieldOverridesToDeploy = spec.fieldOverrides;\n            const existingIndexes = yield this.listIndexes(project);\n            const existingFieldOverrides = yield this.listFieldOverrides(project);\n            if (existingIndexes.length > indexesToDeploy.length) {\n                utils.logBullet(clc.bold.cyan(\"firestore:\") +\n                    \" there are some indexes defined in your project that are not present in your \" +\n                    \"firestore indexes file. Run firebase firestore:indexes and save the result to correct the discrepancy.\");\n            }\n            for (const index of indexesToDeploy) {\n                const exists = existingIndexes.some((x) => this.indexMatchesSpec(x, index));\n                if (exists) {\n                    logger.debug(`Skipping existing index: ${JSON.stringify(index)}`);\n                }\n                else {\n                    logger.debug(`Creating new index: ${JSON.stringify(index)}`);\n                    yield this.createIndex(project, index);\n                }\n            }\n            if (existingFieldOverrides.length > fieldOverridesToDeploy.length) {\n                utils.logBullet(clc.bold.cyan(\"firestore:\") +\n                    \" there are some field overrides defined in your project that are not present in your \" +\n                    \"firestore indexes file. Run firebase firestore:indexes and save the result to correct the discrepancy.\");\n            }\n            for (const field of fieldOverridesToDeploy) {\n                const exists = existingFieldOverrides.some((x) => this.fieldMatchesSpec(x, field));\n                if (exists) {\n                    logger.debug(`Skipping existing field override: ${JSON.stringify(field)}`);\n                }\n                else {\n                    logger.debug(`Updating field override: ${JSON.stringify(field)}`);\n                    yield this.patchField(project, field);\n                }\n            }\n        });\n    }\n    listIndexes(project) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `projects/${project}/databases/(default)/collectionGroups/-/indexes`;\n            const res = yield api.request(\"GET\", `/v1beta2/${url}`, {\n                auth: true,\n                origin: api.firestoreOrigin,\n            });\n            const indexes = res.body.indexes;\n            if (!indexes) {\n                return [];\n            }\n            return indexes.map((index) => {\n                const fields = index.fields.filter((field) => {\n                    return field.fieldPath !== \"__name__\";\n                });\n                return {\n                    name: index.name,\n                    state: index.state,\n                    queryScope: index.queryScope,\n                    fields,\n                };\n            });\n        });\n    }\n    listFieldOverrides(project) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const parent = `projects/${project}/databases/(default)/collectionGroups/-`;\n            const url = `${parent}/fields?filter=indexConfig.usesAncestorConfig=false`;\n            const res = yield api.request(\"GET\", `/v1beta2/${url}`, {\n                auth: true,\n                origin: api.firestoreOrigin,\n            });\n            const fields = res.body.fields;\n            if (!fields) {\n                return [];\n            }\n            return fields.filter((field) => {\n                return field.name.indexOf(\"__default__\") < 0;\n            });\n        });\n    }\n    makeIndexSpec(indexes, fields) {\n        const indexesJson = indexes.map((index) => {\n            return {\n                collectionGroup: util.parseIndexName(index.name).collectionGroupId,\n                queryScope: index.queryScope,\n                fields: index.fields,\n            };\n        });\n        if (!fields) {\n            logger.debug(\"No field overrides specified, using [].\");\n            fields = [];\n        }\n        const fieldsJson = fields.map((field) => {\n            const parsedName = util.parseFieldName(field.name);\n            const fieldIndexes = field.indexConfig.indexes || [];\n            return {\n                collectionGroup: parsedName.collectionGroupId,\n                fieldPath: parsedName.fieldPath,\n                indexes: fieldIndexes.map((index) => {\n                    const firstField = index.fields[0];\n                    return {\n                        order: firstField.order,\n                        arrayConfig: firstField.arrayConfig,\n                        queryScope: index.queryScope,\n                    };\n                }),\n            };\n        });\n        const sortedIndexes = indexesJson.sort(sort.compareSpecIndex);\n        const sortedFields = fieldsJson.sort(sort.compareFieldOverride);\n        return {\n            indexes: sortedIndexes,\n            fieldOverrides: sortedFields,\n        };\n    }\n    prettyPrintIndexes(indexes) {\n        if (indexes.length === 0) {\n            logger.info(\"None\");\n            return;\n        }\n        const sortedIndexes = indexes.sort(sort.compareApiIndex);\n        sortedIndexes.forEach((index) => {\n            logger.info(this.prettyIndexString(index));\n        });\n    }\n    printFieldOverrides(fields) {\n        if (fields.length === 0) {\n            logger.info(\"None\");\n            return;\n        }\n        const sortedFields = fields.sort(sort.compareApiField);\n        sortedFields.forEach((field) => {\n            logger.info(this.prettyFieldString(field));\n        });\n    }\n    validateSpec(spec) {\n        validator.assertHas(spec, \"indexes\");\n        spec.indexes.forEach((index) => {\n            this.validateIndex(index);\n        });\n        if (spec.fieldOverrides) {\n            spec.fieldOverrides.forEach((field) => {\n                this.validateField(field);\n            });\n        }\n    }\n    validateIndex(index) {\n        validator.assertHas(index, \"collectionGroup\");\n        validator.assertHas(index, \"queryScope\");\n        validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n        validator.assertHas(index, \"fields\");\n        index.fields.forEach((field) => {\n            validator.assertHas(field, \"fieldPath\");\n            validator.assertHasOneOf(field, [\"order\", \"arrayConfig\"]);\n            if (field.order) {\n                validator.assertEnum(field, \"order\", Object.keys(API.Order));\n            }\n            if (field.arrayConfig) {\n                validator.assertEnum(field, \"arrayConfig\", Object.keys(API.ArrayConfig));\n            }\n        });\n    }\n    validateField(field) {\n        validator.assertHas(field, \"collectionGroup\");\n        validator.assertHas(field, \"fieldPath\");\n        validator.assertHas(field, \"indexes\");\n        field.indexes.forEach((index) => {\n            validator.assertHasOneOf(index, [\"arrayConfig\", \"order\"]);\n            if (index.arrayConfig) {\n                validator.assertEnum(index, \"arrayConfig\", Object.keys(API.ArrayConfig));\n            }\n            if (index.order) {\n                validator.assertEnum(index, \"order\", Object.keys(API.Order));\n            }\n            if (index.queryScope) {\n                validator.assertEnum(index, \"queryScope\", Object.keys(API.QueryScope));\n            }\n        });\n    }\n    patchField(project, spec) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = `projects/${project}/databases/(default)/collectionGroups/${spec.collectionGroup}/fields/${spec.fieldPath}`;\n            const indexes = spec.indexes.map((index) => {\n                return {\n                    queryScope: index.queryScope,\n                    fields: [\n                        {\n                            fieldPath: spec.fieldPath,\n                            arrayConfig: index.arrayConfig,\n                            order: index.order,\n                        },\n                    ],\n                };\n            });\n            const data = {\n                indexConfig: {\n                    indexes,\n                },\n            };\n            yield api.request(\"PATCH\", `/v1beta2/${url}`, {\n                auth: true,\n                origin: api.firestoreOrigin,\n                data,\n            });\n        });\n    }\n    createIndex(project, index) {\n        const url = `projects/${project}/databases/(default)/collectionGroups/${index.collectionGroup}/indexes`;\n        return api.request(\"POST\", \"/v1beta2/\" + url, {\n            auth: true,\n            data: {\n                fields: index.fields,\n                queryScope: index.queryScope,\n            },\n            origin: api.firestoreOrigin,\n        });\n    }\n    indexMatchesSpec(index, spec) {\n        const collection = util.parseIndexName(index.name).collectionGroupId;\n        if (collection !== spec.collectionGroup) {\n            return false;\n        }\n        if (index.queryScope !== spec.queryScope) {\n            return false;\n        }\n        if (index.fields.length !== spec.fields.length) {\n            return false;\n        }\n        let i = 0;\n        while (i < index.fields.length) {\n            const iField = index.fields[i];\n            const sField = spec.fields[i];\n            if (iField.fieldPath !== sField.fieldPath) {\n                return false;\n            }\n            if (iField.order !== sField.order) {\n                return false;\n            }\n            if (iField.arrayConfig !== sField.arrayConfig) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n    fieldMatchesSpec(field, spec) {\n        const parsedName = util.parseFieldName(field.name);\n        if (parsedName.collectionGroupId !== spec.collectionGroup) {\n            return false;\n        }\n        if (parsedName.fieldPath !== spec.fieldPath) {\n            return false;\n        }\n        const fieldIndexes = field.indexConfig.indexes || [];\n        if (fieldIndexes.length !== spec.indexes.length) {\n            return false;\n        }\n        const fieldModes = fieldIndexes.map((index) => {\n            const firstField = index.fields[0];\n            return firstField.order || firstField.arrayConfig;\n        });\n        const specModes = spec.indexes.map((index) => {\n            return index.order || index.arrayConfig;\n        });\n        for (const mode of fieldModes) {\n            if (specModes.indexOf(mode) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    upgradeOldSpec(spec) {\n        const result = {\n            indexes: [],\n            fieldOverrides: spec.fieldOverrides || [],\n        };\n        if (!(spec.indexes && spec.indexes.length > 0)) {\n            return result;\n        }\n        if (spec.indexes[0].collectionId) {\n            utils.logBullet(clc.bold.cyan(\"firestore:\") +\n                \" your indexes indexes are specified in the v1beta1 API format. \" +\n                \"Please upgrade to the new index API format by running \" +\n                clc.bold(\"firebase firestore:indexes\") +\n                \" again and saving the result.\");\n        }\n        result.indexes = spec.indexes.map((index) => {\n            const i = {\n                collectionGroup: index.collectionGroup || index.collectionId,\n                queryScope: index.queryScope || API.QueryScope.COLLECTION,\n                fields: [],\n            };\n            if (index.fields) {\n                i.fields = index.fields.map((field) => {\n                    const f = {\n                        fieldPath: field.fieldPath,\n                    };\n                    if (field.order) {\n                        f.order = field.order;\n                    }\n                    else if (field.arrayConfig) {\n                        f.arrayConfig = field.arrayConfig;\n                    }\n                    else if (field.mode === API.Mode.ARRAY_CONTAINS) {\n                        f.arrayConfig = API.ArrayConfig.CONTAINS;\n                    }\n                    else {\n                        f.order = field.mode;\n                    }\n                    return f;\n                });\n            }\n            return i;\n        });\n        return result;\n    }\n    prettyIndexString(index) {\n        let result = \"\";\n        if (index.state) {\n            const stateMsg = `[${index.state}] `;\n            if (index.state === API.State.READY) {\n                result += clc.green(stateMsg);\n            }\n            else if (index.state === API.State.CREATING) {\n                result += clc.yellow(stateMsg);\n            }\n            else {\n                result += clc.red(stateMsg);\n            }\n        }\n        const nameInfo = util.parseIndexName(index.name);\n        result += clc.cyan(`(${nameInfo.collectionGroupId})`);\n        result += \" -- \";\n        index.fields.forEach((field) => {\n            if (field.fieldPath === \"__name__\") {\n                return;\n            }\n            const orderOrArrayConfig = field.order ? field.order : field.arrayConfig;\n            result += `(${field.fieldPath},${orderOrArrayConfig}) `;\n        });\n        return result;\n    }\n    prettyFieldString(field) {\n        let result = \"\";\n        const parsedName = util.parseFieldName(field.name);\n        result +=\n            \"[\" +\n                clc.cyan(parsedName.collectionGroupId) +\n                \".\" +\n                clc.yellow(parsedName.fieldPath) +\n                \"] --\";\n        const fieldIndexes = field.indexConfig.indexes || [];\n        if (fieldIndexes.length > 0) {\n            fieldIndexes.forEach((index) => {\n                const firstField = index.fields[0];\n                const mode = firstField.order || firstField.arrayConfig;\n                result += ` (${mode})`;\n            });\n        }\n        else {\n            result += \" (no indexes)\";\n        }\n        return result;\n    }\n}\nexports.FirestoreIndexes = FirestoreIndexes;\n"]},"metadata":{},"sourceType":"script"}