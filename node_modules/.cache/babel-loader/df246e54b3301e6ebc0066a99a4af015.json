{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst precise_date_1 = require(\"@google-cloud/precise-date\");\n\nconst projectify_1 = require(\"@google-cloud/projectify\");\n\nconst promisify_1 = require(\"@google-cloud/promisify\");\n\nconst events_1 = require(\"events\");\n\nconst histogram_1 = require(\"./histogram\");\n\nconst lease_manager_1 = require(\"./lease-manager\");\n\nconst message_queues_1 = require(\"./message-queues\");\n\nconst message_stream_1 = require(\"./message-stream\");\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types.\n *\n * @external PreciseDate\n * @see {@link https://github.com/googleapis/nodejs-precise-date|PreciseDate}\n */\n\n/**\n * Message objects provide a simple interface for users to get message data and\n * acknowledge the message.\n *\n * @example\n * subscription.on('message', message => {\n *   // {\n *   //   ackId: 'RUFeQBJMJAxESVMrQwsqWBFOBCEhPjA',\n *   //   attributes: {key: 'value'},\n *   //   data: Buffer.from('Hello, world!),\n *   //   id: '1551297743043',\n *   //   orderingKey: 'ordering-key',\n *   //   publishTime: new PreciseDate('2019-02-27T20:02:19.029534186Z'),\n *   //   received: 1551297743043,\n *   //   length: 13\n *   // }\n * });\n */\n\n\nclass Message {\n  /**\n   * @hideconstructor\n   *\n   * @param {Subscriber} sub The parent subscriber.\n   * @param {object} message The raw message response.\n   */\n  constructor(sub, {\n    ackId,\n    message,\n    deliveryAttempt\n  }) {\n    /**\n     * This ID is used to acknowledge the message.\n     *\n     * @name Message#ackId\n     * @type {string}\n     */\n    this.ackId = ackId;\n    /**\n     * Optional attributes for this message.\n     *\n     * @name Message#attributes\n     * @type {object}\n     */\n\n    this.attributes = message.attributes || {};\n    /**\n     * The message data as a Buffer.\n     *\n     * @name Message#data\n     * @type {Buffer}\n     */\n\n    this.data = message.data;\n    /**\n     * Delivery attempt counter is 1 + (the sum of number of NACKs and number of\n     * ack_deadline exceeds) for this message.\n     *\n     * @name Message#deliveryAttempt\n     * @type {number}\n     */\n\n    this.deliveryAttempt = Number(deliveryAttempt || 0);\n    /**\n     * ID of the message, assigned by the server when the message is published.\n     * Guaranteed to be unique within the topic.\n     *\n     * @name Message#id\n     * @type {string}\n     */\n\n    this.id = message.messageId;\n    /**\n     * Identifies related messages for which publish order should be respected.\n     * If a `Subscription` has `enableMessageOrdering` set to `true`, messages\n     * published with the same `orderingKey` value will be delivered to\n     * subscribers in the order in which they are received by the Pub/Sub\n     * system.\n     *\n     * **EXPERIMENTAL:** This feature is part of a closed alpha release. This\n     * API might be changed in backward-incompatible ways and is not recommended\n     * for production use. It is not subject to any SLA or deprecation policy.\n     *\n     * @name Message#orderingKey\n     * @type {string}\n     */\n\n    this.orderingKey = message.orderingKey;\n    /**\n     * The time at which the message was published.\n     *\n     * @name Message#publishTime\n     * @type {external:PreciseDate}\n     */\n\n    this.publishTime = new precise_date_1.PreciseDate(message.publishTime);\n    /**\n     * The time at which the message was recieved by the subscription.\n     *\n     * @name Message#received\n     * @type {number}\n     */\n\n    this.received = Date.now();\n    this._handled = false;\n    this._length = this.data.length;\n    this._subscriber = sub;\n  }\n  /**\n   * The length of the message data.\n   *\n   * @type {number}\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Acknowledges the message.\n   *\n   * @example\n   * subscription.on('message', message => {\n   *   message.ack();\n   * });\n   */\n\n\n  ack() {\n    if (!this._handled) {\n      this._handled = true;\n\n      this._subscriber.ack(this);\n    }\n  }\n  /**\n   * Modifies the ack deadline.\n   *\n   * @param {number} deadline The number of seconds to extend the deadline.\n   * @private\n   */\n\n\n  modAck(deadline) {\n    if (!this._handled) {\n      this._subscriber.modAck(this, deadline);\n    }\n  }\n  /**\n   * Removes the message from our inventory and schedules it to be redelivered.\n   *\n   * @example\n   * subscription.on('message', message => {\n   *   message.nack();\n   * });\n   */\n\n\n  nack() {\n    if (!this._handled) {\n      this._handled = true;\n\n      this._subscriber.nack(this);\n    }\n  }\n\n}\n\nexports.Message = Message;\n/**\n * @typedef {object} SubscriberOptions\n * @property {number} [ackDeadline=10] Acknowledge deadline in seconds. If left\n *     unset the initial value will be 10 seconds, but it will evolve into the\n *     99th percentile time it takes to acknowledge a message.\n * @property {BatchOptions} [batching] Request batching options.\n * @property {FlowControlOptions} [flowControl] Flow control options.\n * @property {MessageStreamOptions} [streamingOptions] Streaming options.\n */\n\n/**\n * Subscriber class is used to manage all message related functionality.\n *\n * @private\n * @class\n *\n * @param {Subscription} subscription The corresponding subscription.\n * @param {SubscriberOptions} options The subscriber options.\n */\n\nclass Subscriber extends events_1.EventEmitter {\n  constructor(subscription, options = {}) {\n    super();\n    this.ackDeadline = 10;\n    this.isOpen = false;\n    this._isUserSetDeadline = false;\n    this._histogram = new histogram_1.Histogram({\n      min: 10,\n      max: 600\n    });\n    this._latencies = new histogram_1.Histogram();\n    this._subscription = subscription;\n    this.setOptions(options);\n  }\n  /**\n   * The 99th percentile of request latencies.\n   *\n   * @type {number}\n   * @private\n   */\n\n\n  get modAckLatency() {\n    const latency = this._latencies.percentile(99);\n\n    let bufferTime = 0;\n\n    if (this._modAcks) {\n      bufferTime = this._modAcks.maxMilliseconds;\n    }\n\n    return latency * 1000 + bufferTime;\n  }\n  /**\n   * The full name of the Subscription.\n   *\n   * @type {string}\n   * @private\n   */\n\n\n  get name() {\n    if (!this._name) {\n      const _this$_subscription = this._subscription,\n            name = _this$_subscription.name,\n            projectId = _this$_subscription.projectId;\n      this._name = projectify_1.replaceProjectIdToken(name, projectId);\n    }\n\n    return this._name;\n  }\n  /**\n   * Acknowledges the supplied message.\n   *\n   * @param {Message} message The message to acknowledge.\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async ack(message) {\n    if (!this._isUserSetDeadline) {\n      const ackTimeSeconds = (Date.now() - message.received) / 1000;\n\n      this._histogram.add(ackTimeSeconds);\n\n      this.ackDeadline = this._histogram.percentile(99);\n    }\n\n    this._acks.add(message);\n\n    await this._acks.onFlush();\n\n    this._inventory.remove(message);\n  }\n  /**\n   * Closes the subscriber. The returned promise will resolve once any pending\n   * acks/modAcks are finished.\n   *\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async close() {\n    if (!this.isOpen) {\n      return;\n    }\n\n    this.isOpen = false;\n\n    this._stream.destroy();\n\n    this._inventory.clear();\n\n    await this._waitForFlush();\n    this.emit('close');\n  }\n  /**\n   * Gets the subscriber client instance.\n   *\n   * @returns {Promise<object>}\n   * @private\n   */\n\n\n  async getClient() {\n    const pubsub = this._subscription.pubsub;\n\n    const _ref = await promisify_1.promisify(pubsub.getClient_).call(pubsub, {\n      client: 'SubscriberClient'\n    }),\n          _ref2 = _slicedToArray(_ref, 1),\n          client = _ref2[0];\n\n    return client;\n  }\n  /**\n   * Modifies the acknowledge deadline for the provided message.\n   *\n   * @param {Message} message The message to modify.\n   * @param {number} deadline The deadline.\n   * @returns {Promise}\n   * @private\n   */\n\n\n  async modAck(message, deadline) {\n    const startTime = Date.now();\n\n    this._modAcks.add(message, deadline);\n\n    await this._modAcks.onFlush();\n    const latency = (Date.now() - startTime) / 1000;\n\n    this._latencies.add(latency);\n  }\n  /**\n   * Modfies the acknowledge deadline for the provided message and then removes\n   * it from our inventory.\n   *\n   * @param {Message} message The message.\n   * @return {Promise}\n   * @private\n   */\n\n\n  async nack(message) {\n    await this.modAck(message, 0);\n\n    this._inventory.remove(message);\n  }\n  /**\n   * Starts pulling messages.\n   * @private\n   */\n\n\n  open() {\n    const _this$_options = this._options,\n          batching = _this$_options.batching,\n          flowControl = _this$_options.flowControl,\n          streamingOptions = _this$_options.streamingOptions;\n    this._acks = new message_queues_1.AckQueue(this, batching);\n    this._modAcks = new message_queues_1.ModAckQueue(this, batching);\n    this._inventory = new lease_manager_1.LeaseManager(this, flowControl);\n    this._stream = new message_stream_1.MessageStream(this, streamingOptions);\n\n    this._stream.on('error', err => this.emit('error', err)).on('data', data => this._onData(data)).once('close', () => this.close());\n\n    this._inventory.on('full', () => this._stream.pause()).on('free', () => this._stream.resume());\n\n    this.isOpen = true;\n  }\n  /**\n   * Sets subscriber options.\n   *\n   * @param {SubscriberOptions} options The options.\n   * @private\n   */\n\n\n  setOptions(options) {\n    this._options = options;\n\n    if (options.ackDeadline) {\n      this.ackDeadline = options.ackDeadline;\n      this._isUserSetDeadline = true;\n    } // in the event that the user has specified the maxMessages option, we want\n    // to make sure that the maxStreams option isn't higher\n    // it doesn't really make sense to open 5 streams if the user only wants\n    // 1 message at a time.\n\n\n    if (options.flowControl) {\n      const _options$flowControl$ = options.flowControl.maxMessages,\n            maxMessages = _options$flowControl$ === void 0 ? 100 : _options$flowControl$;\n\n      if (!options.streamingOptions) {\n        options.streamingOptions = {};\n      }\n\n      const _options$streamingOpt = options.streamingOptions.maxStreams,\n            maxStreams = _options$streamingOpt === void 0 ? 5 : _options$streamingOpt;\n      options.streamingOptions.maxStreams = Math.min(maxStreams, maxMessages);\n    }\n  }\n  /**\n   * Callback to be invoked when a new message is available.\n   *\n   * New messages will be added to the subscribers inventory, which in turn will\n   * automatically extend the messages ack deadline until either:\n   *   a. the user acks/nacks it\n   *   b. the maxExtension option is hit\n   *\n   * If the message puts us at/over capacity, then we'll pause our message\n   * stream until we've freed up some inventory space.\n   *\n   * New messages must immediately issue a ModifyAckDeadline request\n   * (aka receipt) to confirm with the backend that we did infact receive the\n   * message and its ok to start ticking down on the deadline.\n   *\n   * @private\n   */\n\n\n  _onData({\n    receivedMessages\n  }) {\n    for (const data of receivedMessages) {\n      const message = new Message(this, data);\n\n      if (this.isOpen) {\n        message.modAck(this.ackDeadline);\n\n        this._inventory.add(message);\n      } else {\n        message.nack();\n      }\n    }\n  }\n  /**\n   * Returns a promise that will resolve once all pending requests have settled.\n   *\n   * @private\n   *\n   * @returns {Promise}\n   */\n\n\n  async _waitForFlush() {\n    const promises = [];\n\n    if (this._acks.numPendingRequests) {\n      promises.push(this._acks.onFlush());\n\n      this._acks.flush();\n    }\n\n    if (this._modAcks.numPendingRequests) {\n      promises.push(this._modAcks.onFlush());\n\n      this._modAcks.flush();\n    }\n\n    await Promise.all(promises);\n  }\n\n}\n\nexports.Subscriber = Subscriber;","map":{"version":3,"sources":["../../src/subscriber.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst precise_date_1 = require(\"@google-cloud/precise-date\");\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst promisify_1 = require(\"@google-cloud/promisify\");\nconst events_1 = require(\"events\");\nconst histogram_1 = require(\"./histogram\");\nconst lease_manager_1 = require(\"./lease-manager\");\nconst message_queues_1 = require(\"./message-queues\");\nconst message_stream_1 = require(\"./message-stream\");\n/**\n * Date object with nanosecond precision. Supports all standard Date arguments\n * in addition to several custom types.\n *\n * @external PreciseDate\n * @see {@link https://github.com/googleapis/nodejs-precise-date|PreciseDate}\n */\n/**\n * Message objects provide a simple interface for users to get message data and\n * acknowledge the message.\n *\n * @example\n * subscription.on('message', message => {\n *   // {\n *   //   ackId: 'RUFeQBJMJAxESVMrQwsqWBFOBCEhPjA',\n *   //   attributes: {key: 'value'},\n *   //   data: Buffer.from('Hello, world!),\n *   //   id: '1551297743043',\n *   //   orderingKey: 'ordering-key',\n *   //   publishTime: new PreciseDate('2019-02-27T20:02:19.029534186Z'),\n *   //   received: 1551297743043,\n *   //   length: 13\n *   // }\n * });\n */\nclass Message {\n    /**\n     * @hideconstructor\n     *\n     * @param {Subscriber} sub The parent subscriber.\n     * @param {object} message The raw message response.\n     */\n    constructor(sub, { ackId, message, deliveryAttempt }) {\n        /**\n         * This ID is used to acknowledge the message.\n         *\n         * @name Message#ackId\n         * @type {string}\n         */\n        this.ackId = ackId;\n        /**\n         * Optional attributes for this message.\n         *\n         * @name Message#attributes\n         * @type {object}\n         */\n        this.attributes = message.attributes || {};\n        /**\n         * The message data as a Buffer.\n         *\n         * @name Message#data\n         * @type {Buffer}\n         */\n        this.data = message.data;\n        /**\n         * Delivery attempt counter is 1 + (the sum of number of NACKs and number of\n         * ack_deadline exceeds) for this message.\n         *\n         * @name Message#deliveryAttempt\n         * @type {number}\n         */\n        this.deliveryAttempt = Number(deliveryAttempt || 0);\n        /**\n         * ID of the message, assigned by the server when the message is published.\n         * Guaranteed to be unique within the topic.\n         *\n         * @name Message#id\n         * @type {string}\n         */\n        this.id = message.messageId;\n        /**\n         * Identifies related messages for which publish order should be respected.\n         * If a `Subscription` has `enableMessageOrdering` set to `true`, messages\n         * published with the same `orderingKey` value will be delivered to\n         * subscribers in the order in which they are received by the Pub/Sub\n         * system.\n         *\n         * **EXPERIMENTAL:** This feature is part of a closed alpha release. This\n         * API might be changed in backward-incompatible ways and is not recommended\n         * for production use. It is not subject to any SLA or deprecation policy.\n         *\n         * @name Message#orderingKey\n         * @type {string}\n         */\n        this.orderingKey = message.orderingKey;\n        /**\n         * The time at which the message was published.\n         *\n         * @name Message#publishTime\n         * @type {external:PreciseDate}\n         */\n        this.publishTime = new precise_date_1.PreciseDate(message.publishTime);\n        /**\n         * The time at which the message was recieved by the subscription.\n         *\n         * @name Message#received\n         * @type {number}\n         */\n        this.received = Date.now();\n        this._handled = false;\n        this._length = this.data.length;\n        this._subscriber = sub;\n    }\n    /**\n     * The length of the message data.\n     *\n     * @type {number}\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * Acknowledges the message.\n     *\n     * @example\n     * subscription.on('message', message => {\n     *   message.ack();\n     * });\n     */\n    ack() {\n        if (!this._handled) {\n            this._handled = true;\n            this._subscriber.ack(this);\n        }\n    }\n    /**\n     * Modifies the ack deadline.\n     *\n     * @param {number} deadline The number of seconds to extend the deadline.\n     * @private\n     */\n    modAck(deadline) {\n        if (!this._handled) {\n            this._subscriber.modAck(this, deadline);\n        }\n    }\n    /**\n     * Removes the message from our inventory and schedules it to be redelivered.\n     *\n     * @example\n     * subscription.on('message', message => {\n     *   message.nack();\n     * });\n     */\n    nack() {\n        if (!this._handled) {\n            this._handled = true;\n            this._subscriber.nack(this);\n        }\n    }\n}\nexports.Message = Message;\n/**\n * @typedef {object} SubscriberOptions\n * @property {number} [ackDeadline=10] Acknowledge deadline in seconds. If left\n *     unset the initial value will be 10 seconds, but it will evolve into the\n *     99th percentile time it takes to acknowledge a message.\n * @property {BatchOptions} [batching] Request batching options.\n * @property {FlowControlOptions} [flowControl] Flow control options.\n * @property {MessageStreamOptions} [streamingOptions] Streaming options.\n */\n/**\n * Subscriber class is used to manage all message related functionality.\n *\n * @private\n * @class\n *\n * @param {Subscription} subscription The corresponding subscription.\n * @param {SubscriberOptions} options The subscriber options.\n */\nclass Subscriber extends events_1.EventEmitter {\n    constructor(subscription, options = {}) {\n        super();\n        this.ackDeadline = 10;\n        this.isOpen = false;\n        this._isUserSetDeadline = false;\n        this._histogram = new histogram_1.Histogram({ min: 10, max: 600 });\n        this._latencies = new histogram_1.Histogram();\n        this._subscription = subscription;\n        this.setOptions(options);\n    }\n    /**\n     * The 99th percentile of request latencies.\n     *\n     * @type {number}\n     * @private\n     */\n    get modAckLatency() {\n        const latency = this._latencies.percentile(99);\n        let bufferTime = 0;\n        if (this._modAcks) {\n            bufferTime = this._modAcks.maxMilliseconds;\n        }\n        return latency * 1000 + bufferTime;\n    }\n    /**\n     * The full name of the Subscription.\n     *\n     * @type {string}\n     * @private\n     */\n    get name() {\n        if (!this._name) {\n            const { name, projectId } = this._subscription;\n            this._name = projectify_1.replaceProjectIdToken(name, projectId);\n        }\n        return this._name;\n    }\n    /**\n     * Acknowledges the supplied message.\n     *\n     * @param {Message} message The message to acknowledge.\n     * @returns {Promise}\n     * @private\n     */\n    async ack(message) {\n        if (!this._isUserSetDeadline) {\n            const ackTimeSeconds = (Date.now() - message.received) / 1000;\n            this._histogram.add(ackTimeSeconds);\n            this.ackDeadline = this._histogram.percentile(99);\n        }\n        this._acks.add(message);\n        await this._acks.onFlush();\n        this._inventory.remove(message);\n    }\n    /**\n     * Closes the subscriber. The returned promise will resolve once any pending\n     * acks/modAcks are finished.\n     *\n     * @returns {Promise}\n     * @private\n     */\n    async close() {\n        if (!this.isOpen) {\n            return;\n        }\n        this.isOpen = false;\n        this._stream.destroy();\n        this._inventory.clear();\n        await this._waitForFlush();\n        this.emit('close');\n    }\n    /**\n     * Gets the subscriber client instance.\n     *\n     * @returns {Promise<object>}\n     * @private\n     */\n    async getClient() {\n        const pubsub = this._subscription.pubsub;\n        const [client] = await promisify_1.promisify(pubsub.getClient_).call(pubsub, {\n            client: 'SubscriberClient',\n        });\n        return client;\n    }\n    /**\n     * Modifies the acknowledge deadline for the provided message.\n     *\n     * @param {Message} message The message to modify.\n     * @param {number} deadline The deadline.\n     * @returns {Promise}\n     * @private\n     */\n    async modAck(message, deadline) {\n        const startTime = Date.now();\n        this._modAcks.add(message, deadline);\n        await this._modAcks.onFlush();\n        const latency = (Date.now() - startTime) / 1000;\n        this._latencies.add(latency);\n    }\n    /**\n     * Modfies the acknowledge deadline for the provided message and then removes\n     * it from our inventory.\n     *\n     * @param {Message} message The message.\n     * @return {Promise}\n     * @private\n     */\n    async nack(message) {\n        await this.modAck(message, 0);\n        this._inventory.remove(message);\n    }\n    /**\n     * Starts pulling messages.\n     * @private\n     */\n    open() {\n        const { batching, flowControl, streamingOptions } = this._options;\n        this._acks = new message_queues_1.AckQueue(this, batching);\n        this._modAcks = new message_queues_1.ModAckQueue(this, batching);\n        this._inventory = new lease_manager_1.LeaseManager(this, flowControl);\n        this._stream = new message_stream_1.MessageStream(this, streamingOptions);\n        this._stream\n            .on('error', err => this.emit('error', err))\n            .on('data', (data) => this._onData(data))\n            .once('close', () => this.close());\n        this._inventory\n            .on('full', () => this._stream.pause())\n            .on('free', () => this._stream.resume());\n        this.isOpen = true;\n    }\n    /**\n     * Sets subscriber options.\n     *\n     * @param {SubscriberOptions} options The options.\n     * @private\n     */\n    setOptions(options) {\n        this._options = options;\n        if (options.ackDeadline) {\n            this.ackDeadline = options.ackDeadline;\n            this._isUserSetDeadline = true;\n        }\n        // in the event that the user has specified the maxMessages option, we want\n        // to make sure that the maxStreams option isn't higher\n        // it doesn't really make sense to open 5 streams if the user only wants\n        // 1 message at a time.\n        if (options.flowControl) {\n            const { maxMessages = 100 } = options.flowControl;\n            if (!options.streamingOptions) {\n                options.streamingOptions = {};\n            }\n            const { maxStreams = 5 } = options.streamingOptions;\n            options.streamingOptions.maxStreams = Math.min(maxStreams, maxMessages);\n        }\n    }\n    /**\n     * Callback to be invoked when a new message is available.\n     *\n     * New messages will be added to the subscribers inventory, which in turn will\n     * automatically extend the messages ack deadline until either:\n     *   a. the user acks/nacks it\n     *   b. the maxExtension option is hit\n     *\n     * If the message puts us at/over capacity, then we'll pause our message\n     * stream until we've freed up some inventory space.\n     *\n     * New messages must immediately issue a ModifyAckDeadline request\n     * (aka receipt) to confirm with the backend that we did infact receive the\n     * message and its ok to start ticking down on the deadline.\n     *\n     * @private\n     */\n    _onData({ receivedMessages }) {\n        for (const data of receivedMessages) {\n            const message = new Message(this, data);\n            if (this.isOpen) {\n                message.modAck(this.ackDeadline);\n                this._inventory.add(message);\n            }\n            else {\n                message.nack();\n            }\n        }\n    }\n    /**\n     * Returns a promise that will resolve once all pending requests have settled.\n     *\n     * @private\n     *\n     * @returns {Promise}\n     */\n    async _waitForFlush() {\n        const promises = [];\n        if (this._acks.numPendingRequests) {\n            promises.push(this._acks.onFlush());\n            this._acks.flush();\n        }\n        if (this._modAcks.numPendingRequests) {\n            promises.push(this._modAcks.onFlush());\n            this._modAcks.flush();\n        }\n        await Promise.all(promises);\n    }\n}\nexports.Subscriber = Subscriber;\n//# sourceMappingURL=subscriber.js.map"]},"metadata":{},"sourceType":"script"}