{"ast":null,"code":"\"use strict\";\n\nvar clc = require(\"cli-color\");\n\nvar ProgressBar = require(\"progress\");\n\nvar api = require(\"../api\");\n\nvar firestore = require(\"../gcp/firestore\");\n\nvar _require = require(\"../error\"),\n    FirebaseError = _require.FirebaseError;\n\nvar logger = require(\"../logger\");\n\nvar utils = require(\"../utils\");\n\nvar MIN_ID = \"__id-9223372036854775808__\";\n\nfunction FirestoreDelete(project, path, options) {\n  this.project = project;\n  this.path = path || \"\";\n  this.recursive = Boolean(options.recursive);\n  this.shallow = Boolean(options.shallow);\n  this.allCollections = Boolean(options.allCollections);\n  this.path = this.path.replace(/(^\\/+|\\/+$)/g, \"\");\n  this.allDescendants = this.recursive;\n  this.root = \"projects/\" + project + \"/databases/(default)/documents\";\n  var segments = this.path.split(\"/\");\n  this.isDocumentPath = segments.length % 2 === 0;\n  this.isCollectionPath = !this.isDocumentPath;\n  this.parent = this.root;\n\n  if (this.isCollectionPath) {\n    segments.pop();\n  }\n\n  if (segments.length > 0) {\n    this.parent += \"/\" + segments.join(\"/\");\n  }\n\n  if (!options.allCollections) {\n    this._validateOptions();\n  }\n}\n\nFirestoreDelete.prototype._validateOptions = function () {\n  if (this.recursive && this.shallow) {\n    throw new FirebaseError(\"Cannot pass recursive and shallow options together.\");\n  }\n\n  if (this.isCollectionPath && !this.recursive && !this.shallow) {\n    throw new FirebaseError(\"Must pass recursive or shallow option when deleting a collection.\");\n  }\n\n  var pieces = this.path.split(\"/\");\n\n  if (pieces.length === 0) {\n    throw new FirebaseError(\"Path length must be greater than zero.\");\n  }\n\n  var hasEmptySegment = pieces.some(function (piece) {\n    return piece.length === 0;\n  });\n\n  if (hasEmptySegment) {\n    throw new FirebaseError(\"Path must not have any empty segments.\");\n  }\n};\n\nFirestoreDelete.prototype._collectionDescendantsQuery = function (allDescendants, batchSize, startAfter) {\n  var nullChar = String.fromCharCode(0);\n  var startAt = this.root + \"/\" + this.path + \"/\" + MIN_ID;\n  var endAt = this.root + \"/\" + this.path + nullChar + \"/\" + MIN_ID;\n  var where = {\n    compositeFilter: {\n      op: \"AND\",\n      filters: [{\n        fieldFilter: {\n          field: {\n            fieldPath: \"__name__\"\n          },\n          op: \"GREATER_THAN_OR_EQUAL\",\n          value: {\n            referenceValue: startAt\n          }\n        }\n      }, {\n        fieldFilter: {\n          field: {\n            fieldPath: \"__name__\"\n          },\n          op: \"LESS_THAN\",\n          value: {\n            referenceValue: endAt\n          }\n        }\n      }]\n    }\n  };\n  var query = {\n    structuredQuery: {\n      where: where,\n      limit: batchSize,\n      from: [{\n        allDescendants: allDescendants\n      }],\n      select: {\n        fields: [{\n          fieldPath: \"__name__\"\n        }]\n      },\n      orderBy: [{\n        field: {\n          fieldPath: \"__name__\"\n        }\n      }]\n    }\n  };\n\n  if (startAfter) {\n    query.structuredQuery.startAt = {\n      values: [{\n        referenceValue: startAfter\n      }],\n      before: false\n    };\n  }\n\n  return query;\n};\n\nFirestoreDelete.prototype._docDescendantsQuery = function (allDescendants, batchSize, startAfter) {\n  var query = {\n    structuredQuery: {\n      limit: batchSize,\n      from: [{\n        allDescendants: allDescendants\n      }],\n      select: {\n        fields: [{\n          fieldPath: \"__name__\"\n        }]\n      },\n      orderBy: [{\n        field: {\n          fieldPath: \"__name__\"\n        }\n      }]\n    }\n  };\n\n  if (startAfter) {\n    query.structuredQuery.startAt = {\n      values: [{\n        referenceValue: startAfter\n      }],\n      before: false\n    };\n  }\n\n  return query;\n};\n\nFirestoreDelete.prototype._getDescendantBatch = function (allDescendants, batchSize, startAfter) {\n  var url = this.parent + \":runQuery\";\n  var body;\n\n  if (this.isDocumentPath) {\n    body = this._docDescendantsQuery(allDescendants, batchSize, startAfter);\n  } else {\n    body = this._collectionDescendantsQuery(allDescendants, batchSize, startAfter);\n  }\n\n  return api.request(\"POST\", \"/v1beta1/\" + url, {\n    auth: true,\n    data: body,\n    origin: api.firestoreOrigin\n  }).then(function (res) {\n    return res.body.filter(function (x) {\n      return x.document;\n    }).map(function (x) {\n      return x.document;\n    });\n  });\n};\n\nFirestoreDelete.progressBar = new ProgressBar(\"Deleted :current docs (:rate docs/s)\\n\", {\n  total: Number.MAX_SAFE_INTEGER\n});\n\nFirestoreDelete.prototype._recursiveBatchDelete = function () {\n  var self = this;\n  var readBatchSize = 7500;\n  var deleteBatchSize = 250;\n  var maxPendingDeletes = 15;\n  var maxQueueSize = deleteBatchSize * maxPendingDeletes * 2;\n  var queue = [];\n  var numPendingDeletes = 0;\n  var pagesRemaining = true;\n  var pageIncoming = false;\n  var lastDocName;\n  var failures = [];\n  var retried = {};\n\n  var queueLoop = function () {\n    if (queue.length == 0 && numPendingDeletes == 0 && !pagesRemaining) {\n      return true;\n    }\n\n    if (failures.length > 0) {\n      logger.debug(\"Found \" + failures.length + \" failed deletes, failing.\");\n      return true;\n    }\n\n    if (queue.length <= maxQueueSize && pagesRemaining && !pageIncoming) {\n      pageIncoming = true;\n\n      self._getDescendantBatch(self.allDescendants, readBatchSize, lastDocName).then(function (docs) {\n        pageIncoming = false;\n\n        if (docs.length == 0) {\n          pagesRemaining = false;\n          return;\n        }\n\n        queue = queue.concat(docs);\n        lastDocName = docs[docs.length - 1].name;\n      }).catch(function (e) {\n        logger.debug(\"Failed to fetch page after \" + lastDocName, e);\n        pageIncoming = false;\n      });\n    }\n\n    if (numPendingDeletes > maxPendingDeletes) {\n      return false;\n    }\n\n    if (queue.length == 0) {\n      return false;\n    }\n\n    var toDelete = [];\n    var numToDelete = Math.min(deleteBatchSize, queue.length);\n\n    for (var i = 0; i < numToDelete; i++) {\n      toDelete.push(queue.shift());\n    }\n\n    numPendingDeletes++;\n    firestore.deleteDocuments(self.project, toDelete).then(function (numDeleted) {\n      FirestoreDelete.progressBar.tick(numDeleted);\n      numPendingDeletes--;\n    }).catch(function (e) {\n      if (e.status >= 500 && e.status < 600) {\n        logger.debug(\"Server error deleting doc batch\", e);\n        toDelete.forEach(function (doc) {\n          if (retried[doc.name]) {\n            logger.debug(\"Failed to delete doc \" + doc.name + \" multiple times.\");\n            failures.push(doc.name);\n          } else {\n            retried[doc.name] = true;\n            queue.push(doc);\n          }\n        });\n      } else {\n        logger.debug(\"Fatal error deleting docs \", e);\n        failures = failures.concat(toDelete);\n      }\n\n      numPendingDeletes--;\n    });\n    return false;\n  };\n\n  return new Promise(function (resolve, reject) {\n    var intervalId = setInterval(function () {\n      if (queueLoop()) {\n        clearInterval(intervalId);\n\n        if (failures.length == 0) {\n          resolve();\n        } else {\n          reject(\"Failed to delete documents \" + failures);\n        }\n      }\n    }, 0);\n  });\n};\n\nFirestoreDelete.prototype._deletePath = function () {\n  var self = this;\n  var initialDelete;\n\n  if (this.isDocumentPath) {\n    var doc = {\n      name: this.root + \"/\" + this.path\n    };\n    initialDelete = firestore.deleteDocument(doc).catch(function (err) {\n      logger.debug(\"deletePath:initialDelete:error\", err);\n\n      if (self.allDescendants) {\n        return Promise.resolve();\n      }\n\n      return utils.reject(\"Unable to delete \" + clc.cyan(this.path));\n    });\n  } else {\n    initialDelete = Promise.resolve();\n  }\n\n  return initialDelete.then(function () {\n    return self._recursiveBatchDelete();\n  });\n};\n\nFirestoreDelete.prototype.deleteDatabase = function () {\n  var self = this;\n  return firestore.listCollectionIds(this.project).catch(function (err) {\n    logger.debug(\"deleteDatabase:listCollectionIds:error\", err);\n    return utils.reject(\"Unable to list collection IDs\");\n  }).then(function (collectionIds) {\n    var promises = [];\n    logger.info(\"Deleting the following collections: \" + clc.cyan(collectionIds.join(\", \")));\n\n    for (var i = 0; i < collectionIds.length; i++) {\n      var collectionId = collectionIds[i];\n      var deleteOp = new FirestoreDelete(self.project, collectionId, {\n        recursive: true\n      });\n      promises.push(deleteOp.execute());\n    }\n\n    return Promise.all(promises);\n  });\n};\n\nFirestoreDelete.prototype.checkHasChildren = function () {\n  return this._getDescendantBatch(true, 1).then(function (docs) {\n    return docs.length > 0;\n  });\n};\n\nFirestoreDelete.prototype.execute = function () {\n  var verifyRecurseSafe;\n\n  if (this.isDocumentPath && !this.recursive && !this.shallow) {\n    verifyRecurseSafe = this.checkHasChildren().then(function (multiple) {\n      if (multiple) {\n        return utils.reject(\"Document has children, must specify -r or --shallow.\", {\n          exit: 1\n        });\n      }\n    });\n  } else {\n    verifyRecurseSafe = Promise.resolve();\n  }\n\n  var self = this;\n  return verifyRecurseSafe.then(function () {\n    return self._deletePath();\n  });\n};\n\nmodule.exports = FirestoreDelete;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/firestore/delete.js"],"names":["clc","require","ProgressBar","api","firestore","FirebaseError","logger","utils","MIN_ID","FirestoreDelete","project","path","options","recursive","Boolean","shallow","allCollections","replace","allDescendants","root","segments","split","isDocumentPath","length","isCollectionPath","parent","pop","join","_validateOptions","prototype","pieces","hasEmptySegment","some","piece","_collectionDescendantsQuery","batchSize","startAfter","nullChar","String","fromCharCode","startAt","endAt","where","compositeFilter","op","filters","fieldFilter","field","fieldPath","value","referenceValue","query","structuredQuery","limit","from","select","fields","orderBy","values","before","_docDescendantsQuery","_getDescendantBatch","url","body","request","auth","data","origin","firestoreOrigin","then","res","filter","x","document","map","progressBar","total","Number","MAX_SAFE_INTEGER","_recursiveBatchDelete","self","readBatchSize","deleteBatchSize","maxPendingDeletes","maxQueueSize","queue","numPendingDeletes","pagesRemaining","pageIncoming","lastDocName","failures","retried","queueLoop","debug","docs","concat","name","catch","e","toDelete","numToDelete","Math","min","i","push","shift","deleteDocuments","numDeleted","tick","status","forEach","doc","Promise","resolve","reject","intervalId","setInterval","clearInterval","_deletePath","initialDelete","deleteDocument","err","cyan","deleteDatabase","listCollectionIds","collectionIds","promises","info","collectionId","deleteOp","execute","all","checkHasChildren","verifyRecurseSafe","multiple","exit","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nvar clc = require(\"cli-color\");\nvar ProgressBar = require(\"progress\");\nvar api = require(\"../api\");\nvar firestore = require(\"../gcp/firestore\");\nvar { FirebaseError } = require(\"../error\");\nvar logger = require(\"../logger\");\nvar utils = require(\"../utils\");\nvar MIN_ID = \"__id-9223372036854775808__\";\nfunction FirestoreDelete(project, path, options) {\n    this.project = project;\n    this.path = path || \"\";\n    this.recursive = Boolean(options.recursive);\n    this.shallow = Boolean(options.shallow);\n    this.allCollections = Boolean(options.allCollections);\n    this.path = this.path.replace(/(^\\/+|\\/+$)/g, \"\");\n    this.allDescendants = this.recursive;\n    this.root = \"projects/\" + project + \"/databases/(default)/documents\";\n    var segments = this.path.split(\"/\");\n    this.isDocumentPath = segments.length % 2 === 0;\n    this.isCollectionPath = !this.isDocumentPath;\n    this.parent = this.root;\n    if (this.isCollectionPath) {\n        segments.pop();\n    }\n    if (segments.length > 0) {\n        this.parent += \"/\" + segments.join(\"/\");\n    }\n    if (!options.allCollections) {\n        this._validateOptions();\n    }\n}\nFirestoreDelete.prototype._validateOptions = function () {\n    if (this.recursive && this.shallow) {\n        throw new FirebaseError(\"Cannot pass recursive and shallow options together.\");\n    }\n    if (this.isCollectionPath && !this.recursive && !this.shallow) {\n        throw new FirebaseError(\"Must pass recursive or shallow option when deleting a collection.\");\n    }\n    var pieces = this.path.split(\"/\");\n    if (pieces.length === 0) {\n        throw new FirebaseError(\"Path length must be greater than zero.\");\n    }\n    var hasEmptySegment = pieces.some(function (piece) {\n        return piece.length === 0;\n    });\n    if (hasEmptySegment) {\n        throw new FirebaseError(\"Path must not have any empty segments.\");\n    }\n};\nFirestoreDelete.prototype._collectionDescendantsQuery = function (allDescendants, batchSize, startAfter) {\n    var nullChar = String.fromCharCode(0);\n    var startAt = this.root + \"/\" + this.path + \"/\" + MIN_ID;\n    var endAt = this.root + \"/\" + this.path + nullChar + \"/\" + MIN_ID;\n    var where = {\n        compositeFilter: {\n            op: \"AND\",\n            filters: [\n                {\n                    fieldFilter: {\n                        field: {\n                            fieldPath: \"__name__\",\n                        },\n                        op: \"GREATER_THAN_OR_EQUAL\",\n                        value: {\n                            referenceValue: startAt,\n                        },\n                    },\n                },\n                {\n                    fieldFilter: {\n                        field: {\n                            fieldPath: \"__name__\",\n                        },\n                        op: \"LESS_THAN\",\n                        value: {\n                            referenceValue: endAt,\n                        },\n                    },\n                },\n            ],\n        },\n    };\n    var query = {\n        structuredQuery: {\n            where: where,\n            limit: batchSize,\n            from: [\n                {\n                    allDescendants: allDescendants,\n                },\n            ],\n            select: {\n                fields: [{ fieldPath: \"__name__\" }],\n            },\n            orderBy: [{ field: { fieldPath: \"__name__\" } }],\n        },\n    };\n    if (startAfter) {\n        query.structuredQuery.startAt = {\n            values: [{ referenceValue: startAfter }],\n            before: false,\n        };\n    }\n    return query;\n};\nFirestoreDelete.prototype._docDescendantsQuery = function (allDescendants, batchSize, startAfter) {\n    var query = {\n        structuredQuery: {\n            limit: batchSize,\n            from: [\n                {\n                    allDescendants: allDescendants,\n                },\n            ],\n            select: {\n                fields: [{ fieldPath: \"__name__\" }],\n            },\n            orderBy: [{ field: { fieldPath: \"__name__\" } }],\n        },\n    };\n    if (startAfter) {\n        query.structuredQuery.startAt = {\n            values: [{ referenceValue: startAfter }],\n            before: false,\n        };\n    }\n    return query;\n};\nFirestoreDelete.prototype._getDescendantBatch = function (allDescendants, batchSize, startAfter) {\n    var url = this.parent + \":runQuery\";\n    var body;\n    if (this.isDocumentPath) {\n        body = this._docDescendantsQuery(allDescendants, batchSize, startAfter);\n    }\n    else {\n        body = this._collectionDescendantsQuery(allDescendants, batchSize, startAfter);\n    }\n    return api\n        .request(\"POST\", \"/v1beta1/\" + url, {\n        auth: true,\n        data: body,\n        origin: api.firestoreOrigin,\n    })\n        .then(function (res) {\n        return res.body\n            .filter(function (x) {\n            return x.document;\n        })\n            .map(function (x) {\n            return x.document;\n        });\n    });\n};\nFirestoreDelete.progressBar = new ProgressBar(\"Deleted :current docs (:rate docs/s)\\n\", {\n    total: Number.MAX_SAFE_INTEGER,\n});\nFirestoreDelete.prototype._recursiveBatchDelete = function () {\n    var self = this;\n    var readBatchSize = 7500;\n    var deleteBatchSize = 250;\n    var maxPendingDeletes = 15;\n    var maxQueueSize = deleteBatchSize * maxPendingDeletes * 2;\n    var queue = [];\n    var numPendingDeletes = 0;\n    var pagesRemaining = true;\n    var pageIncoming = false;\n    var lastDocName;\n    var failures = [];\n    var retried = {};\n    var queueLoop = function () {\n        if (queue.length == 0 && numPendingDeletes == 0 && !pagesRemaining) {\n            return true;\n        }\n        if (failures.length > 0) {\n            logger.debug(\"Found \" + failures.length + \" failed deletes, failing.\");\n            return true;\n        }\n        if (queue.length <= maxQueueSize && pagesRemaining && !pageIncoming) {\n            pageIncoming = true;\n            self\n                ._getDescendantBatch(self.allDescendants, readBatchSize, lastDocName)\n                .then(function (docs) {\n                pageIncoming = false;\n                if (docs.length == 0) {\n                    pagesRemaining = false;\n                    return;\n                }\n                queue = queue.concat(docs);\n                lastDocName = docs[docs.length - 1].name;\n            })\n                .catch(function (e) {\n                logger.debug(\"Failed to fetch page after \" + lastDocName, e);\n                pageIncoming = false;\n            });\n        }\n        if (numPendingDeletes > maxPendingDeletes) {\n            return false;\n        }\n        if (queue.length == 0) {\n            return false;\n        }\n        var toDelete = [];\n        var numToDelete = Math.min(deleteBatchSize, queue.length);\n        for (var i = 0; i < numToDelete; i++) {\n            toDelete.push(queue.shift());\n        }\n        numPendingDeletes++;\n        firestore\n            .deleteDocuments(self.project, toDelete)\n            .then(function (numDeleted) {\n            FirestoreDelete.progressBar.tick(numDeleted);\n            numPendingDeletes--;\n        })\n            .catch(function (e) {\n            if (e.status >= 500 && e.status < 600) {\n                logger.debug(\"Server error deleting doc batch\", e);\n                toDelete.forEach(function (doc) {\n                    if (retried[doc.name]) {\n                        logger.debug(\"Failed to delete doc \" + doc.name + \" multiple times.\");\n                        failures.push(doc.name);\n                    }\n                    else {\n                        retried[doc.name] = true;\n                        queue.push(doc);\n                    }\n                });\n            }\n            else {\n                logger.debug(\"Fatal error deleting docs \", e);\n                failures = failures.concat(toDelete);\n            }\n            numPendingDeletes--;\n        });\n        return false;\n    };\n    return new Promise(function (resolve, reject) {\n        var intervalId = setInterval(function () {\n            if (queueLoop()) {\n                clearInterval(intervalId);\n                if (failures.length == 0) {\n                    resolve();\n                }\n                else {\n                    reject(\"Failed to delete documents \" + failures);\n                }\n            }\n        }, 0);\n    });\n};\nFirestoreDelete.prototype._deletePath = function () {\n    var self = this;\n    var initialDelete;\n    if (this.isDocumentPath) {\n        var doc = { name: this.root + \"/\" + this.path };\n        initialDelete = firestore.deleteDocument(doc).catch(function (err) {\n            logger.debug(\"deletePath:initialDelete:error\", err);\n            if (self.allDescendants) {\n                return Promise.resolve();\n            }\n            return utils.reject(\"Unable to delete \" + clc.cyan(this.path));\n        });\n    }\n    else {\n        initialDelete = Promise.resolve();\n    }\n    return initialDelete.then(function () {\n        return self._recursiveBatchDelete();\n    });\n};\nFirestoreDelete.prototype.deleteDatabase = function () {\n    var self = this;\n    return firestore\n        .listCollectionIds(this.project)\n        .catch(function (err) {\n        logger.debug(\"deleteDatabase:listCollectionIds:error\", err);\n        return utils.reject(\"Unable to list collection IDs\");\n    })\n        .then(function (collectionIds) {\n        var promises = [];\n        logger.info(\"Deleting the following collections: \" + clc.cyan(collectionIds.join(\", \")));\n        for (var i = 0; i < collectionIds.length; i++) {\n            var collectionId = collectionIds[i];\n            var deleteOp = new FirestoreDelete(self.project, collectionId, {\n                recursive: true,\n            });\n            promises.push(deleteOp.execute());\n        }\n        return Promise.all(promises);\n    });\n};\nFirestoreDelete.prototype.checkHasChildren = function () {\n    return this._getDescendantBatch(true, 1).then(function (docs) {\n        return docs.length > 0;\n    });\n};\nFirestoreDelete.prototype.execute = function () {\n    var verifyRecurseSafe;\n    if (this.isDocumentPath && !this.recursive && !this.shallow) {\n        verifyRecurseSafe = this.checkHasChildren().then(function (multiple) {\n            if (multiple) {\n                return utils.reject(\"Document has children, must specify -r or --shallow.\", { exit: 1 });\n            }\n        });\n    }\n    else {\n        verifyRecurseSafe = Promise.resolve();\n    }\n    var self = this;\n    return verifyRecurseSafe.then(function () {\n        return self._deletePath();\n    });\n};\nmodule.exports = FirestoreDelete;\n"]},"metadata":{},"sourceType":"script"}