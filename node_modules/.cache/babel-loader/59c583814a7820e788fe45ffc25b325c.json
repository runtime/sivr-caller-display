{"ast":null,"code":"\"use strict\";\n\nconst clc = require(\"cli-color\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst request = require(\"request\");\n\nconst size = require(\"lodash/size\");\n\nconst zlib = require(\"zlib\");\n\nconst crypto = require(\"crypto\");\n\nconst hashcache = require(\"./hashcache\");\n\nconst detectProjectRoot = require(\"../../detectProjectRoot\");\n\nconst api = require(\"../../api\");\n\nconst logger = require(\"../../logger\");\n\nconst _require = require(\"../../throttler/queue\"),\n      Queue = _require.Queue;\n\nconst MIN_UPLOAD_TIMEOUT = 30000;\nconst MAX_UPLOAD_TIMEOUT = 7200000;\n\nfunction _progressMessage(message, current, total) {\n  current = Math.min(current, total);\n  const percent = Math.floor(current * 1.0 / total * 100).toString();\n  return `${message} [${current}/${total}] (${clc.bold.green(`${percent}%`)})`;\n}\n\nclass Uploader {\n  constructor(options) {\n    this.version = options.version;\n    this.cwd = options.cwd || process.cwd();\n    this.projectRoot = detectProjectRoot(this.cwd);\n    this.gzipLevel = options.gzipLevel || 9;\n    this.hashQueue = new Queue({\n      name: \"hashQueue\",\n      concurrency: options.hashConcurrency || 50,\n      handler: this.hashHandler.bind(this)\n    });\n    this.populateBatchSize = options.populateBatchSize || 1000;\n    this.populateBatch = {};\n    this.populateQueue = new Queue({\n      name: \"populateQueue\",\n      concurrency: options.populateConcurrency || 10,\n      handler: this.populateHandler.bind(this),\n      retries: 3\n    });\n    this.uploadQueue = new Queue({\n      name: \"uploadQueue\",\n      concurrency: options.uploadConcurrency || 200,\n      handler: this.uploadHandler.bind(this),\n      retries: 5\n    });\n    this.public = options.public || this.cwd;\n    this.files = options.files;\n    this.fileCount = this.files.length;\n    this.cache = hashcache.load(this.projectRoot, this.hashcacheName());\n    this.cacheNew = new Map();\n    this.sizeMap = {};\n    this.hashMap = {};\n    this.pathMap = {};\n  }\n\n  hashcacheName() {\n    return Buffer.from(path.relative(this.projectRoot, this.public)).toString(\"base64\").replace(/=+$/, \"\");\n  }\n\n  start() {\n    const self = this;\n\n    if (this.files.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.files.forEach(function (f) {\n      self.hashQueue.add(f);\n    });\n    self.hashQueue.close();\n    self.hashQueue.process();\n    self.hashQueue.wait().then(self.queuePopulate.bind(self)).then(function () {\n      hashcache.dump(self.projectRoot, self.hashcacheName(), self.cacheNew);\n      logger.debug(\"[hosting][hash queue][FINAL]\", self.hashQueue.stats());\n      self.populateQueue.close();\n      return self.populateQueue.wait();\n    }).then(function () {\n      logger.debug(\"[hosting][populate queue][FINAL]\", self.populateQueue.stats());\n      logger.debug(\"[hosting] uploads queued:\", self.uploadQueue.stats().total);\n      self.uploadQueue.close();\n    });\n\n    const fin = function (err) {\n      logger.debug(\"[hosting][upload queue][FINAL]\", self.uploadQueue.stats());\n      if (err) throw err;\n    };\n\n    return this.wait().then(fin).catch(fin);\n  }\n\n  wait() {\n    return Promise.all([this.hashQueue.wait(), this.populateQueue.wait(), this.uploadQueue.wait()]).then(function () {\n      return;\n    });\n  }\n\n  statusMessage() {\n    if (!this.hashQueue.finished) {\n      return _progressMessage(\"hashing files\", this.hashQueue.complete, this.fileCount);\n    } else if (!this.populateQueue.finished) {\n      return _progressMessage(\"adding files to version\", this.populateQueue.complete * 1000, this.fileCount);\n    } else if (!this.uploadQueue.finished) {\n      return _progressMessage(\"uploading new files\", this.uploadQueue.complete, this.uploadQueue.stats().total);\n    } else {\n      return \"upload complete\";\n    }\n  }\n\n  hashHandler(filePath) {\n    const stats = fs.statSync(path.resolve(this.public, filePath));\n    const mtime = stats.mtime.getTime();\n    this.sizeMap[filePath] = stats.size;\n    const cached = this.cache[filePath];\n\n    if (cached && cached.mtime === mtime) {\n      this.cacheNew.set(filePath, cached);\n      this.addHash(filePath, cached.hash);\n      return Promise.resolve();\n    }\n\n    const fstream = this._zipStream(filePath);\n\n    const hash = crypto.createHash(\"sha256\");\n    fstream.pipe(hash);\n    const self = this;\n    return new Promise(function (resolve, reject) {\n      fstream.on(\"end\", function () {\n        const hashVal = hash.read().toString(\"hex\");\n        self.cacheNew.set(filePath, {\n          mtime: mtime,\n          hash: hashVal\n        });\n        self.addHash(filePath, hashVal);\n        resolve();\n      });\n      fstream.on(\"error\", reject);\n    });\n  }\n\n  addHash(filePath, hash) {\n    this.hashMap[hash] = filePath;\n    this.pathMap[filePath] = hash;\n    this.populateBatch[\"/\" + filePath] = hash;\n    this.populateCount++;\n    const curBatchSize = size(this.populateBatch);\n\n    if (curBatchSize > 0 && curBatchSize % this.populateBatchSize === 0) {\n      this.queuePopulate();\n    }\n  }\n\n  queuePopulate() {\n    const pop = this.populateBatch;\n    this.populateQueue.add(pop);\n    this.populateBatch = {};\n    this.populateQueue.process();\n  }\n\n  populateHandler(batch) {\n    const self = this;\n    return api.request(\"POST\", \"/v1beta1/\" + self.version + \":populateFiles\", {\n      origin: api.hostingApiOrigin,\n      auth: true,\n      data: {\n        files: batch\n      },\n      logOptions: {\n        skipRequestBody: true\n      },\n      timeout: 60000\n    }).then(function (result) {\n      self.uploadUrl = result.body.uploadUrl;\n      self.addUploads(result.body.uploadRequiredHashes || []);\n    });\n  }\n\n  addUploads(hashes) {\n    const self = this;\n    hashes.forEach(function (hash) {\n      self.uploadQueue.add(hash);\n    });\n    self.uploadQueue.process();\n  }\n\n  uploadHandler(toUpload) {\n    const self = this;\n    return api.addRequestHeaders({\n      url: this.uploadUrl + \"/\" + toUpload\n    }).then(function (reqOpts) {\n      return new Promise(function (resolve, reject) {\n        self._zipStream(self.hashMap[toUpload]).pipe(request.post(Object.assign(reqOpts, {\n          timeout: self._uploadTimeout(self.hashMap[toUpload])\n        }), function (err, res) {\n          if (self.uploadQueue.cursor % 100 === 0) {\n            logger.debug(\"[hosting][upload]\", self.uploadQueue.stats());\n          }\n\n          if (err) {\n            return reject(err);\n          } else if (res.statusCode !== 200) {\n            logger.debug(\"[hosting][upload]\", self.hashMap[toUpload], \"(\" + toUpload + \")\", \"HTTP ERROR\", res.statusCode, \":\", res.headers, res.body);\n            return reject(new Error(\"Unexpected error while uploading file.\"));\n          }\n\n          resolve();\n        }));\n      });\n    });\n  }\n\n  _zipStream(filePath) {\n    const gzip = zlib.createGzip({\n      level: this.gzipLevel\n    });\n    return fs.createReadStream(path.resolve(this.public, filePath)).pipe(gzip);\n  }\n\n  _uploadTimeout(filePath) {\n    const size = this.sizeMap[filePath] || 0;\n    return Math.min(Math.max(Math.round(size / 1000) * 20, MIN_UPLOAD_TIMEOUT), MAX_UPLOAD_TIMEOUT);\n  }\n\n}\n\nmodule.exports = Uploader;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/deploy/hosting/uploader.js"],"names":["clc","require","fs","path","request","size","zlib","crypto","hashcache","detectProjectRoot","api","logger","Queue","MIN_UPLOAD_TIMEOUT","MAX_UPLOAD_TIMEOUT","_progressMessage","message","current","total","Math","min","percent","floor","toString","bold","green","Uploader","constructor","options","version","cwd","process","projectRoot","gzipLevel","hashQueue","name","concurrency","hashConcurrency","handler","hashHandler","bind","populateBatchSize","populateBatch","populateQueue","populateConcurrency","populateHandler","retries","uploadQueue","uploadConcurrency","uploadHandler","public","files","fileCount","length","cache","load","hashcacheName","cacheNew","Map","sizeMap","hashMap","pathMap","Buffer","from","relative","replace","start","self","Promise","resolve","forEach","f","add","close","wait","then","queuePopulate","dump","debug","stats","fin","err","catch","all","statusMessage","finished","complete","filePath","statSync","mtime","getTime","cached","set","addHash","hash","fstream","_zipStream","createHash","pipe","reject","on","hashVal","read","populateCount","curBatchSize","pop","batch","origin","hostingApiOrigin","auth","data","logOptions","skipRequestBody","timeout","result","uploadUrl","body","addUploads","uploadRequiredHashes","hashes","toUpload","addRequestHeaders","url","reqOpts","post","Object","assign","_uploadTimeout","res","cursor","statusCode","headers","Error","gzip","createGzip","level","createReadStream","max","round","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst clc = require(\"cli-color\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst request = require(\"request\");\nconst size = require(\"lodash/size\");\nconst zlib = require(\"zlib\");\nconst crypto = require(\"crypto\");\nconst hashcache = require(\"./hashcache\");\nconst detectProjectRoot = require(\"../../detectProjectRoot\");\nconst api = require(\"../../api\");\nconst logger = require(\"../../logger\");\nconst { Queue } = require(\"../../throttler/queue\");\nconst MIN_UPLOAD_TIMEOUT = 30000;\nconst MAX_UPLOAD_TIMEOUT = 7200000;\nfunction _progressMessage(message, current, total) {\n    current = Math.min(current, total);\n    const percent = Math.floor(((current * 1.0) / total) * 100).toString();\n    return `${message} [${current}/${total}] (${clc.bold.green(`${percent}%`)})`;\n}\nclass Uploader {\n    constructor(options) {\n        this.version = options.version;\n        this.cwd = options.cwd || process.cwd();\n        this.projectRoot = detectProjectRoot(this.cwd);\n        this.gzipLevel = options.gzipLevel || 9;\n        this.hashQueue = new Queue({\n            name: \"hashQueue\",\n            concurrency: options.hashConcurrency || 50,\n            handler: this.hashHandler.bind(this),\n        });\n        this.populateBatchSize = options.populateBatchSize || 1000;\n        this.populateBatch = {};\n        this.populateQueue = new Queue({\n            name: \"populateQueue\",\n            concurrency: options.populateConcurrency || 10,\n            handler: this.populateHandler.bind(this),\n            retries: 3,\n        });\n        this.uploadQueue = new Queue({\n            name: \"uploadQueue\",\n            concurrency: options.uploadConcurrency || 200,\n            handler: this.uploadHandler.bind(this),\n            retries: 5,\n        });\n        this.public = options.public || this.cwd;\n        this.files = options.files;\n        this.fileCount = this.files.length;\n        this.cache = hashcache.load(this.projectRoot, this.hashcacheName());\n        this.cacheNew = new Map();\n        this.sizeMap = {};\n        this.hashMap = {};\n        this.pathMap = {};\n    }\n    hashcacheName() {\n        return Buffer.from(path.relative(this.projectRoot, this.public))\n            .toString(\"base64\")\n            .replace(/=+$/, \"\");\n    }\n    start() {\n        const self = this;\n        if (this.files.length === 0) {\n            return Promise.resolve();\n        }\n        this.files.forEach(function (f) {\n            self.hashQueue.add(f);\n        });\n        self.hashQueue.close();\n        self.hashQueue.process();\n        self.hashQueue\n            .wait()\n            .then(self.queuePopulate.bind(self))\n            .then(function () {\n            hashcache.dump(self.projectRoot, self.hashcacheName(), self.cacheNew);\n            logger.debug(\"[hosting][hash queue][FINAL]\", self.hashQueue.stats());\n            self.populateQueue.close();\n            return self.populateQueue.wait();\n        })\n            .then(function () {\n            logger.debug(\"[hosting][populate queue][FINAL]\", self.populateQueue.stats());\n            logger.debug(\"[hosting] uploads queued:\", self.uploadQueue.stats().total);\n            self.uploadQueue.close();\n        });\n        const fin = function (err) {\n            logger.debug(\"[hosting][upload queue][FINAL]\", self.uploadQueue.stats());\n            if (err)\n                throw err;\n        };\n        return this.wait()\n            .then(fin)\n            .catch(fin);\n    }\n    wait() {\n        return Promise.all([\n            this.hashQueue.wait(),\n            this.populateQueue.wait(),\n            this.uploadQueue.wait(),\n        ]).then(function () {\n            return;\n        });\n    }\n    statusMessage() {\n        if (!this.hashQueue.finished) {\n            return _progressMessage(\"hashing files\", this.hashQueue.complete, this.fileCount);\n        }\n        else if (!this.populateQueue.finished) {\n            return _progressMessage(\"adding files to version\", this.populateQueue.complete * 1000, this.fileCount);\n        }\n        else if (!this.uploadQueue.finished) {\n            return _progressMessage(\"uploading new files\", this.uploadQueue.complete, this.uploadQueue.stats().total);\n        }\n        else {\n            return \"upload complete\";\n        }\n    }\n    hashHandler(filePath) {\n        const stats = fs.statSync(path.resolve(this.public, filePath));\n        const mtime = stats.mtime.getTime();\n        this.sizeMap[filePath] = stats.size;\n        const cached = this.cache[filePath];\n        if (cached && cached.mtime === mtime) {\n            this.cacheNew.set(filePath, cached);\n            this.addHash(filePath, cached.hash);\n            return Promise.resolve();\n        }\n        const fstream = this._zipStream(filePath);\n        const hash = crypto.createHash(\"sha256\");\n        fstream.pipe(hash);\n        const self = this;\n        return new Promise(function (resolve, reject) {\n            fstream.on(\"end\", function () {\n                const hashVal = hash.read().toString(\"hex\");\n                self.cacheNew.set(filePath, { mtime: mtime, hash: hashVal });\n                self.addHash(filePath, hashVal);\n                resolve();\n            });\n            fstream.on(\"error\", reject);\n        });\n    }\n    addHash(filePath, hash) {\n        this.hashMap[hash] = filePath;\n        this.pathMap[filePath] = hash;\n        this.populateBatch[\"/\" + filePath] = hash;\n        this.populateCount++;\n        const curBatchSize = size(this.populateBatch);\n        if (curBatchSize > 0 && curBatchSize % this.populateBatchSize === 0) {\n            this.queuePopulate();\n        }\n    }\n    queuePopulate() {\n        const pop = this.populateBatch;\n        this.populateQueue.add(pop);\n        this.populateBatch = {};\n        this.populateQueue.process();\n    }\n    populateHandler(batch) {\n        const self = this;\n        return api\n            .request(\"POST\", \"/v1beta1/\" + self.version + \":populateFiles\", {\n            origin: api.hostingApiOrigin,\n            auth: true,\n            data: { files: batch },\n            logOptions: { skipRequestBody: true },\n            timeout: 60000,\n        })\n            .then(function (result) {\n            self.uploadUrl = result.body.uploadUrl;\n            self.addUploads(result.body.uploadRequiredHashes || []);\n        });\n    }\n    addUploads(hashes) {\n        const self = this;\n        hashes.forEach(function (hash) {\n            self.uploadQueue.add(hash);\n        });\n        self.uploadQueue.process();\n    }\n    uploadHandler(toUpload) {\n        const self = this;\n        return api\n            .addRequestHeaders({\n            url: this.uploadUrl + \"/\" + toUpload,\n        })\n            .then(function (reqOpts) {\n            return new Promise(function (resolve, reject) {\n                self._zipStream(self.hashMap[toUpload]).pipe(request.post(Object.assign(reqOpts, {\n                    timeout: self._uploadTimeout(self.hashMap[toUpload]),\n                }), function (err, res) {\n                    if (self.uploadQueue.cursor % 100 === 0) {\n                        logger.debug(\"[hosting][upload]\", self.uploadQueue.stats());\n                    }\n                    if (err) {\n                        return reject(err);\n                    }\n                    else if (res.statusCode !== 200) {\n                        logger.debug(\"[hosting][upload]\", self.hashMap[toUpload], \"(\" + toUpload + \")\", \"HTTP ERROR\", res.statusCode, \":\", res.headers, res.body);\n                        return reject(new Error(\"Unexpected error while uploading file.\"));\n                    }\n                    resolve();\n                }));\n            });\n        });\n    }\n    _zipStream(filePath) {\n        const gzip = zlib.createGzip({ level: this.gzipLevel });\n        return fs.createReadStream(path.resolve(this.public, filePath)).pipe(gzip);\n    }\n    _uploadTimeout(filePath) {\n        const size = this.sizeMap[filePath] || 0;\n        return Math.min(Math.max(Math.round(size / 1000) * 20, MIN_UPLOAD_TIMEOUT), MAX_UPLOAD_TIMEOUT);\n    }\n}\nmodule.exports = Uploader;\n"]},"metadata":{},"sourceType":"script"}