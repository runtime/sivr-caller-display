{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst logger = require(\"../logger\");\n\nconst retries_exhausted_error_1 = require(\"./errors/retries-exhausted-error\");\n\nconst timeout_error_1 = require(\"./errors/timeout-error\");\n\nfunction backoff(retryNumber, delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay * Math.pow(2, retryNumber));\n  });\n}\n\nfunction DEFAULT_HANDLER(task) {\n  return task();\n}\n\nclass Throttler {\n  constructor(options) {\n    this.name = \"\";\n    this.concurrency = 200;\n    this.handler = DEFAULT_HANDLER;\n    this.active = 0;\n    this.complete = 0;\n    this.success = 0;\n    this.errored = 0;\n    this.retried = 0;\n    this.total = 0;\n    this.taskDataMap = new Map();\n    this.waits = [];\n    this.min = 9999999999;\n    this.max = 0;\n    this.avg = 0;\n    this.retries = 0;\n    this.backoff = 200;\n    this.closed = false;\n    this.finished = false;\n    this.startTime = 0;\n\n    if (options.name) {\n      this.name = options.name;\n    }\n\n    if (options.handler) {\n      this.handler = options.handler;\n    }\n\n    if (typeof options.concurrency === \"number\") {\n      this.concurrency = options.concurrency;\n    }\n\n    if (typeof options.retries === \"number\") {\n      this.retries = options.retries;\n    }\n\n    if (typeof options.backoff === \"number\") {\n      this.backoff = options.backoff;\n    }\n\n    if (typeof options.backoff === \"number\") {\n      this.backoff = options.backoff;\n    }\n  }\n\n  wait() {\n    const p = new Promise((resolve, reject) => {\n      this.waits.push({\n        resolve,\n        reject\n      });\n    });\n    return p;\n  }\n\n  add(task, timeoutMillis) {\n    this.addHelper(task, timeoutMillis);\n  }\n\n  run(task, timeoutMillis) {\n    return new Promise((resolve, reject) => {\n      this.addHelper(task, timeoutMillis, {\n        resolve,\n        reject\n      });\n    });\n  }\n\n  close() {\n    this.closed = true;\n    return this.finishIfIdle();\n  }\n\n  process() {\n    if (this.finishIfIdle() || this.active >= this.concurrency || !this.hasWaitingTask()) {\n      return;\n    }\n\n    this.active++;\n    this.handle(this.nextWaitingTaskIndex());\n  }\n\n  handle(cursorIndex) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskData = this.taskDataMap.get(cursorIndex);\n\n      if (!taskData) {\n        throw new Error(`taskData.get(${cursorIndex}) does not exist`);\n      }\n\n      const promises = [this.executeTask(cursorIndex)];\n\n      if (taskData.timeoutMillis) {\n        promises.push(this.initializeTimeout(cursorIndex));\n      }\n\n      let result;\n\n      try {\n        result = yield Promise.race(promises);\n      } catch (err) {\n        this.errored++;\n        this.complete++;\n        this.active--;\n        this.onTaskFailed(err, cursorIndex);\n        return;\n      }\n\n      this.success++;\n      this.complete++;\n      this.active--;\n      this.onTaskFulfilled(result, cursorIndex);\n    });\n  }\n\n  stats() {\n    return {\n      max: this.max,\n      min: this.min,\n      avg: this.avg,\n      active: this.active,\n      complete: this.complete,\n      success: this.success,\n      errored: this.errored,\n      retried: this.retried,\n      total: this.total,\n      elapsed: Date.now() - this.startTime\n    };\n  }\n\n  taskName(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n\n    if (!taskData) {\n      return \"finished task\";\n    }\n\n    return typeof taskData.task === \"string\" ? taskData.task : `index ${cursorIndex}`;\n  }\n\n  addHelper(task, timeoutMillis, wait) {\n    if (this.closed) {\n      throw new Error(\"Cannot add a task to a closed throttler.\");\n    }\n\n    if (!this.startTime) {\n      this.startTime = Date.now();\n    }\n\n    this.taskDataMap.set(this.total, {\n      task,\n      wait,\n      timeoutMillis,\n      retryCount: 0,\n      isTimedOut: false\n    });\n    this.total++;\n    this.process();\n  }\n\n  finishIfIdle() {\n    if (this.closed && !this.hasWaitingTask() && this.active === 0) {\n      this.finish();\n      return true;\n    }\n\n    return false;\n  }\n\n  finish(err) {\n    this.waits.forEach(p => {\n      if (err) {\n        return p.reject(err);\n      }\n\n      this.finished = true;\n      return p.resolve();\n    });\n  }\n\n  initializeTimeout(cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n    const timeoutMillis = taskData.timeoutMillis;\n    const timeoutPromise = new Promise((_, reject) => {\n      taskData.timeoutId = setTimeout(() => {\n        taskData.isTimedOut = true;\n        reject(new timeout_error_1.default(this.taskName(cursorIndex), timeoutMillis));\n      }, timeoutMillis);\n    });\n    return timeoutPromise;\n  }\n\n  executeTask(cursorIndex) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const taskData = this.taskDataMap.get(cursorIndex);\n      const t0 = Date.now();\n      let result;\n\n      try {\n        result = yield this.handler(taskData.task);\n      } catch (err) {\n        if (taskData.retryCount === this.retries) {\n          throw new retries_exhausted_error_1.default(this.taskName(cursorIndex), this.retries, err);\n        }\n\n        yield backoff(taskData.retryCount + 1, this.backoff);\n\n        if (taskData.isTimedOut) {\n          throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n        }\n\n        this.retried++;\n        taskData.retryCount++;\n        logger.debug(`[${this.name}] Retrying task`, this.taskName(cursorIndex));\n        return this.executeTask(cursorIndex);\n      }\n\n      if (taskData.isTimedOut) {\n        throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n      }\n\n      const dt = Date.now() - t0;\n      this.min = Math.min(dt, this.min);\n      this.max = Math.max(dt, this.max);\n      this.avg = (this.avg * this.complete + dt) / (this.complete + 1);\n      return result;\n    });\n  }\n\n  onTaskFulfilled(result, cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n\n    if (taskData.wait) {\n      taskData.wait.resolve(result);\n    }\n\n    this.cleanupTask(cursorIndex);\n    this.process();\n  }\n\n  onTaskFailed(error, cursorIndex) {\n    const taskData = this.taskDataMap.get(cursorIndex);\n    logger.debug(error);\n\n    if (taskData.wait) {\n      taskData.wait.reject(error);\n    }\n\n    this.cleanupTask(cursorIndex);\n    this.finish(error);\n  }\n\n  cleanupTask(cursorIndex) {\n    const _this$taskDataMap$get = this.taskDataMap.get(cursorIndex),\n          timeoutId = _this$taskDataMap$get.timeoutId;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    this.taskDataMap.delete(cursorIndex);\n  }\n\n}\n\nexports.Throttler = Throttler;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/throttler/throttler.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","logger","require","retries_exhausted_error_1","timeout_error_1","backoff","retryNumber","delay","setTimeout","Math","pow","DEFAULT_HANDLER","task","Throttler","constructor","options","name","concurrency","handler","active","complete","success","errored","retried","total","taskDataMap","Map","waits","min","max","avg","retries","closed","finished","startTime","wait","p","push","add","timeoutMillis","addHelper","run","close","finishIfIdle","process","hasWaitingTask","handle","nextWaitingTaskIndex","cursorIndex","taskData","get","Error","promises","executeTask","initializeTimeout","race","err","onTaskFailed","onTaskFulfilled","stats","elapsed","Date","now","taskName","set","retryCount","isTimedOut","finish","forEach","timeoutPromise","_","timeoutId","default","t0","debug","dt","cleanupTask","error","clearTimeout","delete"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger = require(\"../logger\");\nconst retries_exhausted_error_1 = require(\"./errors/retries-exhausted-error\");\nconst timeout_error_1 = require(\"./errors/timeout-error\");\nfunction backoff(retryNumber, delay) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, delay * Math.pow(2, retryNumber));\n    });\n}\nfunction DEFAULT_HANDLER(task) {\n    return task();\n}\nclass Throttler {\n    constructor(options) {\n        this.name = \"\";\n        this.concurrency = 200;\n        this.handler = DEFAULT_HANDLER;\n        this.active = 0;\n        this.complete = 0;\n        this.success = 0;\n        this.errored = 0;\n        this.retried = 0;\n        this.total = 0;\n        this.taskDataMap = new Map();\n        this.waits = [];\n        this.min = 9999999999;\n        this.max = 0;\n        this.avg = 0;\n        this.retries = 0;\n        this.backoff = 200;\n        this.closed = false;\n        this.finished = false;\n        this.startTime = 0;\n        if (options.name) {\n            this.name = options.name;\n        }\n        if (options.handler) {\n            this.handler = options.handler;\n        }\n        if (typeof options.concurrency === \"number\") {\n            this.concurrency = options.concurrency;\n        }\n        if (typeof options.retries === \"number\") {\n            this.retries = options.retries;\n        }\n        if (typeof options.backoff === \"number\") {\n            this.backoff = options.backoff;\n        }\n        if (typeof options.backoff === \"number\") {\n            this.backoff = options.backoff;\n        }\n    }\n    wait() {\n        const p = new Promise((resolve, reject) => {\n            this.waits.push({ resolve, reject });\n        });\n        return p;\n    }\n    add(task, timeoutMillis) {\n        this.addHelper(task, timeoutMillis);\n    }\n    run(task, timeoutMillis) {\n        return new Promise((resolve, reject) => {\n            this.addHelper(task, timeoutMillis, { resolve, reject });\n        });\n    }\n    close() {\n        this.closed = true;\n        return this.finishIfIdle();\n    }\n    process() {\n        if (this.finishIfIdle() || this.active >= this.concurrency || !this.hasWaitingTask()) {\n            return;\n        }\n        this.active++;\n        this.handle(this.nextWaitingTaskIndex());\n    }\n    handle(cursorIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const taskData = this.taskDataMap.get(cursorIndex);\n            if (!taskData) {\n                throw new Error(`taskData.get(${cursorIndex}) does not exist`);\n            }\n            const promises = [this.executeTask(cursorIndex)];\n            if (taskData.timeoutMillis) {\n                promises.push(this.initializeTimeout(cursorIndex));\n            }\n            let result;\n            try {\n                result = yield Promise.race(promises);\n            }\n            catch (err) {\n                this.errored++;\n                this.complete++;\n                this.active--;\n                this.onTaskFailed(err, cursorIndex);\n                return;\n            }\n            this.success++;\n            this.complete++;\n            this.active--;\n            this.onTaskFulfilled(result, cursorIndex);\n        });\n    }\n    stats() {\n        return {\n            max: this.max,\n            min: this.min,\n            avg: this.avg,\n            active: this.active,\n            complete: this.complete,\n            success: this.success,\n            errored: this.errored,\n            retried: this.retried,\n            total: this.total,\n            elapsed: Date.now() - this.startTime,\n        };\n    }\n    taskName(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        if (!taskData) {\n            return \"finished task\";\n        }\n        return typeof taskData.task === \"string\" ? taskData.task : `index ${cursorIndex}`;\n    }\n    addHelper(task, timeoutMillis, wait) {\n        if (this.closed) {\n            throw new Error(\"Cannot add a task to a closed throttler.\");\n        }\n        if (!this.startTime) {\n            this.startTime = Date.now();\n        }\n        this.taskDataMap.set(this.total, {\n            task,\n            wait,\n            timeoutMillis,\n            retryCount: 0,\n            isTimedOut: false,\n        });\n        this.total++;\n        this.process();\n    }\n    finishIfIdle() {\n        if (this.closed && !this.hasWaitingTask() && this.active === 0) {\n            this.finish();\n            return true;\n        }\n        return false;\n    }\n    finish(err) {\n        this.waits.forEach((p) => {\n            if (err) {\n                return p.reject(err);\n            }\n            this.finished = true;\n            return p.resolve();\n        });\n    }\n    initializeTimeout(cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        const timeoutMillis = taskData.timeoutMillis;\n        const timeoutPromise = new Promise((_, reject) => {\n            taskData.timeoutId = setTimeout(() => {\n                taskData.isTimedOut = true;\n                reject(new timeout_error_1.default(this.taskName(cursorIndex), timeoutMillis));\n            }, timeoutMillis);\n        });\n        return timeoutPromise;\n    }\n    executeTask(cursorIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const taskData = this.taskDataMap.get(cursorIndex);\n            const t0 = Date.now();\n            let result;\n            try {\n                result = yield this.handler(taskData.task);\n            }\n            catch (err) {\n                if (taskData.retryCount === this.retries) {\n                    throw new retries_exhausted_error_1.default(this.taskName(cursorIndex), this.retries, err);\n                }\n                yield backoff(taskData.retryCount + 1, this.backoff);\n                if (taskData.isTimedOut) {\n                    throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n                }\n                this.retried++;\n                taskData.retryCount++;\n                logger.debug(`[${this.name}] Retrying task`, this.taskName(cursorIndex));\n                return this.executeTask(cursorIndex);\n            }\n            if (taskData.isTimedOut) {\n                throw new timeout_error_1.default(this.taskName(cursorIndex), taskData.timeoutMillis);\n            }\n            const dt = Date.now() - t0;\n            this.min = Math.min(dt, this.min);\n            this.max = Math.max(dt, this.max);\n            this.avg = (this.avg * this.complete + dt) / (this.complete + 1);\n            return result;\n        });\n    }\n    onTaskFulfilled(result, cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        if (taskData.wait) {\n            taskData.wait.resolve(result);\n        }\n        this.cleanupTask(cursorIndex);\n        this.process();\n    }\n    onTaskFailed(error, cursorIndex) {\n        const taskData = this.taskDataMap.get(cursorIndex);\n        logger.debug(error);\n        if (taskData.wait) {\n            taskData.wait.reject(error);\n        }\n        this.cleanupTask(cursorIndex);\n        this.finish(error);\n    }\n    cleanupTask(cursorIndex) {\n        const { timeoutId } = this.taskDataMap.get(cursorIndex);\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        this.taskDataMap.delete(cursorIndex);\n    }\n}\nexports.Throttler = Throttler;\n"]},"metadata":{},"sourceType":"script"}