{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar LRU = require('lru-cache');\n\nvar resolveCommand = require('./resolveCommand');\n\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({\n  max: 50,\n  maxAge: 30 * 1000\n}); // Cache just for 30sec\n\nfunction readShebang(command) {\n  var buffer;\n  var fd;\n  var match;\n  var shebang; // Check if it is in the cache first\n\n  if (shebangCache.has(command)) {\n    return shebangCache.get(command);\n  } // Read the first 150 bytes from the file\n\n\n  buffer = new Buffer(150);\n\n  try {\n    fd = fs.openSync(command, 'r');\n    fs.readSync(fd, buffer, 0, 150, 0);\n    fs.closeSync(fd);\n  } catch (e) {}\n  /* empty */\n  // Check if it is a shebang\n\n\n  match = buffer.toString().trim().match(/#!(.+)/i);\n\n  if (match) {\n    shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, ''); // Remove /usr/bin/env\n  } // Store the shebang in the cache\n\n\n  shebangCache.set(command, shebang);\n  return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n  // Convert to string\n  arg = '' + arg; // If we are not going to quote the argument,\n  // escape shell metacharacters, including double and single quotes:\n\n  if (!quote) {\n    arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n  } else {\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"'); // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n\n    arg = arg.replace(/(\\\\*)$/, '$1$1'); // All other backslashes occur literally\n    // Quote the whole thing:\n\n    arg = '\"' + arg + '\"';\n  }\n\n  return arg;\n}\n\nfunction escapeCommand(command) {\n  // Do not escape if this command is not dangerous..\n  // We do this so that commands like \"echo\" or \"ifconfig\" work\n  // Quoting them, will make them unaccessible\n  return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction requiresShell(command) {\n  return !/\\.(?:com|exe)$/i.test(command);\n}\n\nfunction parse(command, args, options) {\n  var shebang;\n  var applyQuotes;\n  var file;\n  var original;\n  var shell; // Normalize arguments, similar to nodejs\n\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = options || {};\n  original = command;\n\n  if (isWin) {\n    // Detect & add support for shebangs\n    file = resolveCommand(command);\n    file = file || resolveCommand(command, true);\n    shebang = file && readShebang(file);\n    shell = options.shell || hasBrokenSpawn;\n\n    if (shebang) {\n      args.unshift(file);\n      command = shebang;\n      shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n    } else {\n      shell = shell || requiresShell(file);\n    }\n\n    if (shell) {\n      // Escape command & arguments\n      applyQuotes = command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n\n      command = escapeCommand(command);\n      args = args.map(function (arg) {\n        return escapeArg(arg, applyQuotes);\n      }); // Use cmd.exe\n\n      args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n      command = process.env.comspec || 'cmd.exe'; // Tell node's spawn that the arguments are already escaped\n\n      options.windowsVerbatimArguments = true;\n    }\n  }\n\n  return {\n    command: command,\n    args: args,\n    options: options,\n    file: file,\n    original: original\n  };\n}\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/node_modules/cross-spawn/lib/parse.js"],"names":["fs","require","LRU","resolveCommand","hasBrokenSpawn","isWin","process","platform","shebangCache","max","maxAge","readShebang","command","buffer","fd","match","shebang","has","get","Buffer","openSync","readSync","closeSync","e","toString","trim","replace","set","escapeArg","arg","quote","escapeCommand","test","requiresShell","parse","args","options","applyQuotes","file","original","shell","Array","isArray","slice","unshift","map","length","join","env","comspec","windowsVerbatimArguments","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar LRU = require('lru-cache');\nvar resolveCommand = require('./resolveCommand');\nvar hasBrokenSpawn = require('./hasBrokenSpawn');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({ max: 50, maxAge: 30 * 1000 });  // Cache just for 30sec\n\nfunction readShebang(command) {\n    var buffer;\n    var fd;\n    var match;\n    var shebang;\n\n    // Check if it is in the cache first\n    if (shebangCache.has(command)) {\n        return shebangCache.get(command);\n    }\n\n    // Read the first 150 bytes from the file\n    buffer = new Buffer(150);\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, 150, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* empty */ }\n\n    // Check if it is a shebang\n    match = buffer.toString().trim().match(/#!(.+)/i);\n\n    if (match) {\n        shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, '');   // Remove /usr/bin/env\n    }\n\n    // Store the shebang in the cache\n    shebangCache.set(command, shebang);\n\n    return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n    // Convert to string\n    arg = '' + arg;\n\n    // If we are not going to quote the argument,\n    // escape shell metacharacters, including double and single quotes:\n    if (!quote) {\n        arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n    } else {\n        // Sequence of backslashes followed by a double quote:\n        // double up all the backslashes and escape the double quote\n        arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n        // Sequence of backslashes followed by the end of the string\n        // (which will become a double quote later):\n        // double up all the backslashes\n        arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n        // All other backslashes occur literally\n\n        // Quote the whole thing:\n        arg = '\"' + arg + '\"';\n    }\n\n    return arg;\n}\n\nfunction escapeCommand(command) {\n    // Do not escape if this command is not dangerous..\n    // We do this so that commands like \"echo\" or \"ifconfig\" work\n    // Quoting them, will make them unaccessible\n    return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction requiresShell(command) {\n    return !/\\.(?:com|exe)$/i.test(command);\n}\n\nfunction parse(command, args, options) {\n    var shebang;\n    var applyQuotes;\n    var file;\n    var original;\n    var shell;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n    original = command;\n\n    if (isWin) {\n        // Detect & add support for shebangs\n        file = resolveCommand(command);\n        file = file || resolveCommand(command, true);\n        shebang = file && readShebang(file);\n        shell = options.shell || hasBrokenSpawn;\n\n        if (shebang) {\n            args.unshift(file);\n            command = shebang;\n            shell = shell || requiresShell(resolveCommand(shebang) || resolveCommand(shebang, true));\n        } else {\n            shell = shell || requiresShell(file);\n        }\n\n        if (shell) {\n            // Escape command & arguments\n            applyQuotes = (command !== 'echo');  // Do not quote arguments for the special \"echo\" command\n            command = escapeCommand(command);\n            args = args.map(function (arg) {\n                return escapeArg(arg, applyQuotes);\n            });\n\n            // Use cmd.exe\n            args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n            command = process.env.comspec || 'cmd.exe';\n\n            // Tell node's spawn that the arguments are already escaped\n            options.windowsVerbatimArguments = true;\n        }\n    }\n\n    return {\n        command: command,\n        args: args,\n        options: options,\n        file: file,\n        original: original,\n    };\n}\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}