{"ast":null,"code":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\n'use strict';\n\nvar crypto = require('crypto');\n\nvar fs = require('fs');\n\nvar pathjoin = require('join-path');\n\nvar RSVP = require('rsvp');\n\nvar _ = require('lodash');\n\nvar statPromise = RSVP.denodeify(fs.stat);\n\nvar multiStat = function (paths) {\n  var pathname = paths.shift();\n  return statPromise(pathname).then(function (stat) {\n    stat.path = pathname;\n    return stat;\n  }, function (err) {\n    if (paths.length) {\n      return multiStat(paths);\n    }\n\n    return RSVP.reject(err);\n  });\n};\n\nmodule.exports = function (options) {\n  var etagCache = {};\n  var cwd = options.cwd || process.cwd();\n  var publicPaths = options.public || ['.'];\n\n  if (!_.isArray(publicPaths)) {\n    publicPaths = [publicPaths];\n  }\n\n  function _fetchEtag(pathname, stat) {\n    return new RSVP.Promise(function (resolve, reject) {\n      var cached = etagCache[pathname];\n\n      if (cached && cached.timestamp === stat.mtime) {\n        return resolve(cached.value);\n      } // the file you want to get the hash\n\n\n      var fd = fs.createReadStream(pathname);\n      var hash = crypto.createHash('md5');\n      hash.setEncoding('hex');\n      fd.on('error', function (err) {\n        reject(err);\n      });\n      fd.on('end', function () {\n        hash.end();\n        var etag = hash.read();\n        etagCache[pathname] = {\n          timestamp: stat.mtime,\n          value: etag\n        };\n        resolve(etag);\n      }); // read all file and pipe it (write it) to the hash object\n\n      return fd.pipe(hash);\n    });\n  }\n\n  return function (req, pathname) {\n    pathname = decodeURI(pathname); // jumping to parent directories is not allowed\n\n    if (pathname.indexOf('../') >= 0 || pathname.indexOf('..\\\\') >= 0 || pathname.toLowerCase().indexOf('..%5c') >= 0) {\n      return RSVP.resolve(null);\n    }\n\n    var result = {};\n    var foundPath;\n    var fullPathnames = publicPaths.map(function (p) {\n      return pathjoin(cwd, p, pathname);\n    });\n    return multiStat(fullPathnames).then(function (stat) {\n      foundPath = stat.path;\n      result.modified = stat.mtime.getTime();\n      result.size = stat.size;\n      return _fetchEtag(stat.path, stat);\n    }).then(function (etag) {\n      result.etag = etag;\n      result.stream = fs.createReadStream(foundPath);\n      return result;\n    }).catch(function (err) {\n      if (err.code === 'ENOENT' || err.code === 'ENOTDIR' || err.code === 'EISDIR' || err.code === 'EINVAL') {\n        return null;\n      }\n\n      return RSVP.reject(err);\n    });\n  };\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/superstatic/lib/providers/fs.js"],"names":["crypto","require","fs","pathjoin","RSVP","_","statPromise","denodeify","stat","multiStat","paths","pathname","shift","then","path","err","length","reject","module","exports","options","etagCache","cwd","process","publicPaths","public","isArray","_fetchEtag","Promise","resolve","cached","timestamp","mtime","value","fd","createReadStream","hash","createHash","setEncoding","on","end","etag","read","pipe","req","decodeURI","indexOf","toLowerCase","result","foundPath","fullPathnames","map","p","modified","getTime","size","stream","catch","code"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file or at\n * https://github.com/firebase/superstatic/blob/master/LICENSE\n */\n'use strict';\n\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar pathjoin = require('join-path');\nvar RSVP = require('rsvp');\nvar _ = require('lodash');\n\nvar statPromise = RSVP.denodeify(fs.stat);\nvar multiStat = function(paths) {\n  var pathname = paths.shift();\n  return statPromise(pathname).then(function(stat) {\n    stat.path = pathname;\n    return stat;\n  }, function(err) {\n    if (paths.length) {\n      return multiStat(paths);\n    }\n    return RSVP.reject(err);\n  });\n};\n\nmodule.exports = function(options) {\n  var etagCache = {};\n  var cwd = options.cwd || process.cwd();\n  var publicPaths = options.public || ['.'];\n  if (!_.isArray(publicPaths)) {\n    publicPaths = [publicPaths];\n  }\n\n  function _fetchEtag(pathname, stat) {\n    return new RSVP.Promise(function(resolve, reject) {\n      var cached = etagCache[pathname];\n      if (cached && cached.timestamp === stat.mtime) {\n        return resolve(cached.value);\n      }\n\n      // the file you want to get the hash\n      var fd = fs.createReadStream(pathname);\n      var hash = crypto.createHash('md5');\n      hash.setEncoding('hex');\n\n      fd.on('error', function(err) {\n        reject(err);\n      });\n\n      fd.on('end', function() {\n        hash.end();\n        var etag = hash.read();\n        etagCache[pathname] = {\n          timestamp: stat.mtime,\n          value: etag\n        };\n        resolve(etag);\n      });\n\n      // read all file and pipe it (write it) to the hash object\n      return fd.pipe(hash);\n    });\n  }\n\n  return function(req, pathname) {\n    pathname = decodeURI(pathname);\n    // jumping to parent directories is not allowed\n    if (pathname.indexOf('../') >= 0 || pathname.indexOf('..\\\\') >= 0 || pathname.toLowerCase().indexOf('..%5c') >= 0) {\n      return RSVP.resolve(null);\n    }\n\n    var result = {};\n    var foundPath;\n    var fullPathnames = publicPaths.map(function(p) {\n      return pathjoin(cwd, p, pathname);\n    });\n\n    return multiStat(fullPathnames).then(function(stat) {\n      foundPath = stat.path;\n      result.modified = stat.mtime.getTime();\n      result.size = stat.size;\n      return _fetchEtag(stat.path, stat);\n    }).then(function(etag) {\n      result.etag = etag;\n      result.stream = fs.createReadStream(foundPath);\n      return result;\n    }).catch(function(err) {\n      if (err.code === 'ENOENT' || err.code === 'ENOTDIR' || err.code === 'EISDIR' || err.code === 'EINVAL') {\n        return null;\n      }\n      return RSVP.reject(err);\n    });\n  };\n};\n"]},"metadata":{},"sourceType":"script"}