{"ast":null,"code":"module.exports = Extract;\n\nvar Parse = require('./parse');\n\nvar Writer = require('fstream').Writer;\n\nvar path = require('path');\n\nvar stream = require('stream');\n\nvar duplexer2 = require('duplexer2');\n\nvar Promise = require('bluebird');\n\nfunction Extract(opts) {\n  // make sure path is normalized before using it\n  opts.path = path.normalize(opts.path);\n  var parser = new Parse(opts);\n  var outStream = new stream.Writable({\n    objectMode: true\n  });\n\n  outStream._write = function (entry, encoding, cb) {\n    if (entry.type == 'Directory') return cb(); // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n\n    var extractPath = path.join(opts.path, entry.path);\n\n    if (extractPath.indexOf(opts.path) != 0) {\n      return cb();\n    }\n\n    const writer = opts.getWriter ? opts.getWriter({\n      path: extractPath\n    }) : Writer({\n      path: extractPath\n    });\n    entry.pipe(writer).on('error', cb).on('close', cb);\n  };\n\n  var extract = duplexer2(parser, outStream);\n  parser.once('crx-header', function (crxHeader) {\n    extract.crxHeader = crxHeader;\n  });\n  parser.pipe(outStream).on('finish', function () {\n    extract.emit('close');\n  });\n\n  extract.promise = function () {\n    return new Promise(function (resolve, reject) {\n      extract.on('close', resolve);\n      extract.on('error', reject);\n    });\n  };\n\n  return extract;\n}","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/unzipper/lib/extract.js"],"names":["module","exports","Extract","Parse","require","Writer","path","stream","duplexer2","Promise","opts","normalize","parser","outStream","Writable","objectMode","_write","entry","encoding","cb","type","extractPath","join","indexOf","writer","getWriter","pipe","on","extract","once","crxHeader","emit","promise","resolve","reject"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,MAAhC;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAApB;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,UAAD,CAArB;;AAEA,SAASF,OAAT,CAAkBQ,IAAlB,EAAwB;AACtB;AACAA,EAAAA,IAAI,CAACJ,IAAL,GAAYA,IAAI,CAACK,SAAL,CAAeD,IAAI,CAACJ,IAApB,CAAZ;AAEA,MAAIM,MAAM,GAAG,IAAIT,KAAJ,CAAUO,IAAV,CAAb;AAEA,MAAIG,SAAS,GAAG,IAAIN,MAAM,CAACO,QAAX,CAAoB;AAACC,IAAAA,UAAU,EAAE;AAAb,GAApB,CAAhB;;AACAF,EAAAA,SAAS,CAACG,MAAV,GAAmB,UAASC,KAAT,EAAgBC,QAAhB,EAA0BC,EAA1B,EAA8B;AAE/C,QAAIF,KAAK,CAACG,IAAN,IAAc,WAAlB,EAA+B,OAAOD,EAAE,EAAT,CAFgB,CAI/C;AACA;AACA;;AACA,QAAIE,WAAW,GAAGf,IAAI,CAACgB,IAAL,CAAUZ,IAAI,CAACJ,IAAf,EAAqBW,KAAK,CAACX,IAA3B,CAAlB;;AACA,QAAIe,WAAW,CAACE,OAAZ,CAAoBb,IAAI,CAACJ,IAAzB,KAAkC,CAAtC,EAAyC;AACvC,aAAOa,EAAE,EAAT;AACD;;AAED,UAAMK,MAAM,GAAGd,IAAI,CAACe,SAAL,GAAiBf,IAAI,CAACe,SAAL,CAAe;AAACnB,MAAAA,IAAI,EAAEe;AAAP,KAAf,CAAjB,GAAwDhB,MAAM,CAAC;AAAEC,MAAAA,IAAI,EAAEe;AAAR,KAAD,CAA7E;AAEAJ,IAAAA,KAAK,CAACS,IAAN,CAAWF,MAAX,EACGG,EADH,CACM,OADN,EACeR,EADf,EAEGQ,EAFH,CAEM,OAFN,EAEeR,EAFf;AAGD,GAjBD;;AAmBA,MAAIS,OAAO,GAAGpB,SAAS,CAACI,MAAD,EAAQC,SAAR,CAAvB;AACAD,EAAAA,MAAM,CAACiB,IAAP,CAAY,YAAZ,EAA0B,UAASC,SAAT,EAAoB;AAC5CF,IAAAA,OAAO,CAACE,SAAR,GAAoBA,SAApB;AACD,GAFD;AAIAlB,EAAAA,MAAM,CACHc,IADH,CACQb,SADR,EAEGc,EAFH,CAEM,QAFN,EAEe,YAAW;AACtBC,IAAAA,OAAO,CAACG,IAAR,CAAa,OAAb;AACD,GAJH;;AAMAH,EAAAA,OAAO,CAACI,OAAR,GAAkB,YAAW;AAC3B,WAAO,IAAIvB,OAAJ,CAAY,UAASwB,OAAT,EAAkBC,MAAlB,EAA0B;AAC3CN,MAAAA,OAAO,CAACD,EAAR,CAAW,OAAX,EAAoBM,OAApB;AACAL,MAAAA,OAAO,CAACD,EAAR,CAAW,OAAX,EAAmBO,MAAnB;AACD,KAHM,CAAP;AAID,GALD;;AAOA,SAAON,OAAP;AACD","sourcesContent":["module.exports = Extract;\n\nvar Parse = require('./parse');\nvar Writer = require('fstream').Writer;\nvar path = require('path');\nvar stream = require('stream');\nvar duplexer2 = require('duplexer2');\nvar Promise = require('bluebird');\n\nfunction Extract (opts) {\n  // make sure path is normalized before using it\n  opts.path = path.normalize(opts.path);\n\n  var parser = new Parse(opts);\n\n  var outStream = new stream.Writable({objectMode: true});\n  outStream._write = function(entry, encoding, cb) {\n\n    if (entry.type == 'Directory') return cb();\n\n    // to avoid zip slip (writing outside of the destination), we resolve\n    // the target path, and make sure it's nested in the intended\n    // destination, or not extract it otherwise.\n    var extractPath = path.join(opts.path, entry.path);\n    if (extractPath.indexOf(opts.path) != 0) {\n      return cb();\n    }\n\n    const writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n    entry.pipe(writer)\n      .on('error', cb)\n      .on('close', cb);\n  };\n\n  var extract = duplexer2(parser,outStream);\n  parser.once('crx-header', function(crxHeader) {\n    extract.crxHeader = crxHeader;\n  });\n\n  parser\n    .pipe(outStream)\n    .on('finish',function() {\n      extract.emit('close');\n    });\n  \n  extract.promise = function() {\n    return new Promise(function(resolve, reject) {\n      extract.on('close', resolve);\n      extract.on('error',reject);\n    });\n  };\n\n  return extract;\n}\n"]},"metadata":{},"sourceType":"script"}