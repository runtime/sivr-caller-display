{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst clc = require(\"cli-color\");\n\nconst api = require(\"../../api\");\n\nconst convertConfig = require(\"./convertConfig\");\n\nconst deploymentTool = require(\"../../deploymentTool\");\n\nconst _require = require(\"../../error\"),\n      FirebaseError = _require.FirebaseError;\n\nconst fsutils = require(\"../../fsutils\");\n\nconst normalizedHostingConfigs = require(\"../../hosting/normalizedHostingConfigs\");\n\nconst _require2 = require(\"../../projectPath\"),\n      resolveProjectPath = _require2.resolveProjectPath;\n\nmodule.exports = function (context, options) {\n  if (options.public) {\n    if (_.isArray(options.config.get(\"hosting\"))) {\n      throw new FirebaseError(\"Cannot specify --public option with multi-site configuration.\");\n    }\n\n    options.config.importLegacyHostingKeys();\n    options.config.set(\"hosting.public\", options.public);\n  }\n\n  const configs = normalizedHostingConfigs(options);\n\n  if (configs.length === 0) {\n    return Promise.resolve();\n  }\n\n  context.hosting = {\n    deploys: configs.map(function (cfg) {\n      return {\n        config: cfg\n      };\n    })\n  };\n  const versionCreates = [];\n\n  _.each(context.hosting.deploys, function (deploy) {\n    let cfg = deploy.config;\n\n    if (cfg.target) {\n      const matchingTargets = options.rc.requireTarget(options.project, \"hosting\", cfg.target);\n\n      if (matchingTargets.length > 1) {\n        throw new FirebaseError(`Hosting target ${clc.bold(cfg.target)} is linked to multiple sites, ` + `but only one is permitted. ` + `To clear, run:\\n\\n  firebase target:clear hosting ${cfg.target}`);\n      }\n\n      deploy.site = matchingTargets[0];\n    } else if (cfg.site) {\n      deploy.site = cfg.site;\n    } else {\n      throw new FirebaseError('Must supply either \"site\" or \"target\" in each \"hosting\" config.');\n    }\n\n    if (!fsutils.dirExistsSync(resolveProjectPath(options.cwd, cfg.public))) {\n      throw new FirebaseError(`Specified public directory '${cfg.public}' does not exist, ` + `can't deploy hosting to site ${deploy.site}`, {\n        exit: 1\n      });\n    }\n\n    versionCreates.push(api.request(\"POST\", \"/v1beta1/sites/\" + deploy.site + \"/versions\", {\n      origin: api.hostingApiOrigin,\n      auth: true,\n      data: {\n        config: convertConfig(cfg),\n        labels: deploymentTool.labels\n      }\n    }).then(function (result) {\n      deploy.version = result.body.name;\n    }));\n  });\n\n  return Promise.all(versionCreates);\n};","map":{"version":3,"sources":["/Users/Erik.Kroha1/Jobs/Verizon/Talk Home/sivr-caller-display/node_modules/firebase-tools/lib/deploy/hosting/prepare.js"],"names":["_","require","clc","api","convertConfig","deploymentTool","FirebaseError","fsutils","normalizedHostingConfigs","resolveProjectPath","module","exports","context","options","public","isArray","config","get","importLegacyHostingKeys","set","configs","length","Promise","resolve","hosting","deploys","map","cfg","versionCreates","each","deploy","target","matchingTargets","rc","requireTarget","project","bold","site","dirExistsSync","cwd","exit","push","request","origin","hostingApiOrigin","auth","data","labels","then","result","version","body","name","all"],"mappings":"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","sourcesContent":["\"use strict\";\nconst _ = require(\"lodash\");\nconst clc = require(\"cli-color\");\nconst api = require(\"../../api\");\nconst convertConfig = require(\"./convertConfig\");\nconst deploymentTool = require(\"../../deploymentTool\");\nconst { FirebaseError } = require(\"../../error\");\nconst fsutils = require(\"../../fsutils\");\nconst normalizedHostingConfigs = require(\"../../hosting/normalizedHostingConfigs\");\nconst { resolveProjectPath } = require(\"../../projectPath\");\nmodule.exports = function (context, options) {\n    if (options.public) {\n        if (_.isArray(options.config.get(\"hosting\"))) {\n            throw new FirebaseError(\"Cannot specify --public option with multi-site configuration.\");\n        }\n        options.config.importLegacyHostingKeys();\n        options.config.set(\"hosting.public\", options.public);\n    }\n    const configs = normalizedHostingConfigs(options);\n    if (configs.length === 0) {\n        return Promise.resolve();\n    }\n    context.hosting = {\n        deploys: configs.map(function (cfg) {\n            return { config: cfg };\n        }),\n    };\n    const versionCreates = [];\n    _.each(context.hosting.deploys, function (deploy) {\n        let cfg = deploy.config;\n        if (cfg.target) {\n            const matchingTargets = options.rc.requireTarget(options.project, \"hosting\", cfg.target);\n            if (matchingTargets.length > 1) {\n                throw new FirebaseError(`Hosting target ${clc.bold(cfg.target)} is linked to multiple sites, ` +\n                    `but only one is permitted. ` +\n                    `To clear, run:\\n\\n  firebase target:clear hosting ${cfg.target}`);\n            }\n            deploy.site = matchingTargets[0];\n        }\n        else if (cfg.site) {\n            deploy.site = cfg.site;\n        }\n        else {\n            throw new FirebaseError('Must supply either \"site\" or \"target\" in each \"hosting\" config.');\n        }\n        if (!fsutils.dirExistsSync(resolveProjectPath(options.cwd, cfg.public))) {\n            throw new FirebaseError(`Specified public directory '${cfg.public}' does not exist, ` +\n                `can't deploy hosting to site ${deploy.site}`, { exit: 1 });\n        }\n        versionCreates.push(api\n            .request(\"POST\", \"/v1beta1/sites/\" + deploy.site + \"/versions\", {\n            origin: api.hostingApiOrigin,\n            auth: true,\n            data: {\n                config: convertConfig(cfg),\n                labels: deploymentTool.labels,\n            },\n        })\n            .then(function (result) {\n            deploy.version = result.body.name;\n        }));\n    });\n    return Promise.all(versionCreates);\n};\n"]},"metadata":{},"sourceType":"script"}