{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019, Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst call_1 = require(\"../call\");\n\nconst googleError_1 = require(\"../googleError\");\n\nclass PagedApiCaller {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n\n  createActualCallback(request, callback) {\n    const self = this;\n    return function fetchNextPageToken(err, response) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n\n      const resources = response[self.pageDescriptor.resourceField];\n      const pageToken = response[self.pageDescriptor.responsePageTokenField];\n\n      if (pageToken) {\n        request[self.pageDescriptor.requestPageTokenField] = pageToken;\n        callback(err, resources, request, response);\n      } else {\n        callback(err, resources, null, response);\n      }\n    };\n  }\n\n  wrap(func) {\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.createActualCallback(argument, callback));\n    };\n  }\n\n  init(settings, callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n\n    return new call_1.OngoingCallPromise(settings.promise);\n  }\n\n  call(apiCall, argument, settings, canceller) {\n    argument = Object.assign({}, argument);\n\n    if (settings.pageToken) {\n      argument[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n    }\n\n    if (settings.pageSize) {\n      argument[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n    }\n\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      canceller.call(apiCall, argument);\n      return;\n    }\n\n    const maxResults = settings.maxResults || -1;\n    const allResources = [];\n\n    function pushResources(err, resources, next) {\n      if (err) {\n        canceller.callback(err);\n        return;\n      }\n\n      for (let i = 0; i < resources.length; ++i) {\n        allResources.push(resources[i]);\n\n        if (allResources.length === maxResults) {\n          next = null;\n          break;\n        }\n      }\n\n      if (!next) {\n        canceller.callback(null, allResources);\n        return;\n      }\n\n      setImmediate(apiCall, next, pushResources);\n    }\n\n    setImmediate(apiCall, argument, pushResources);\n  }\n\n  fail(canceller, err) {\n    canceller.callback(err);\n  }\n\n  result(canceller) {\n    return canceller.promise;\n  }\n\n}\n\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"sources":["../../../src/paginationCalls/pagedApiCaller.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * Copyright 2019, Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nclass PagedApiCaller {\n    /**\n     * Creates an API caller that returns a stream to performs page-streaming.\n     *\n     * @private\n     * @constructor\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\n     *   of page streaming to be performed.\n     */\n    constructor(pageDescriptor) {\n        this.pageDescriptor = pageDescriptor;\n    }\n    createActualCallback(request, callback) {\n        const self = this;\n        return function fetchNextPageToken(err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (!response) {\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n                return;\n            }\n            const resources = response[self.pageDescriptor.resourceField];\n            const pageToken = response[self.pageDescriptor.responsePageTokenField];\n            if (pageToken) {\n                request[self.pageDescriptor.requestPageTokenField] = pageToken;\n                callback(err, resources, request, response);\n            }\n            else {\n                callback(err, resources, null, response);\n            }\n        };\n    }\n    wrap(func) {\n        const self = this;\n        return function wrappedCall(argument, metadata, options, callback) {\n            return func(argument, metadata, options, self.createActualCallback(argument, callback));\n        };\n    }\n    init(settings, callback) {\n        if (callback) {\n            return new call_1.OngoingCall(callback);\n        }\n        return new call_1.OngoingCallPromise(settings.promise);\n    }\n    call(apiCall, argument, settings, canceller) {\n        argument = Object.assign({}, argument);\n        if (settings.pageToken) {\n            argument[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n        }\n        if (settings.pageSize) {\n            argument[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n        }\n        if (!settings.autoPaginate) {\n            // they don't want auto-pagination this time - okay, just call once\n            canceller.call(apiCall, argument);\n            return;\n        }\n        const maxResults = settings.maxResults || -1;\n        const allResources = [];\n        function pushResources(err, resources, next) {\n            if (err) {\n                canceller.callback(err);\n                return;\n            }\n            for (let i = 0; i < resources.length; ++i) {\n                allResources.push(resources[i]);\n                if (allResources.length === maxResults) {\n                    next = null;\n                    break;\n                }\n            }\n            if (!next) {\n                canceller.callback(null, allResources);\n                return;\n            }\n            setImmediate(apiCall, next, pushResources);\n        }\n        setImmediate(apiCall, argument, pushResources);\n    }\n    fail(canceller, err) {\n        canceller.callback(err);\n    }\n    result(canceller) {\n        return canceller.promise;\n    }\n}\nexports.PagedApiCaller = PagedApiCaller;\n//# sourceMappingURL=pagedApiCaller.js.map"]},"metadata":{},"sourceType":"script"}